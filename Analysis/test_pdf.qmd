---
title: HTW Model
author: Thomas Gorman
date:  last-modified #"`r Sys.Date()`"
page-layout: full
categories: [Modeling, ALM, EXAM, R]
lightbox: true
toc: false
# code-fold: true
# code-tools: true
execute: 
  warning: false
  eval: true
  echo: false
format:
  html: default
  # Manuscript-y PDF output
  pdf:
    output-file: "manuscript-ms.pdf"
    # Custom fonts
    mainfont: "Linux Libertine O"
    mainfontoptions:
      - "Numbers=Proportional"
      - "Numbers=OldStyle"
    mathfont: "Libertinus Math"
---

```{r}
pacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, 
               stringr,future,furrr, knitr, reactable, flextable,ggstance, htmltools,ggdist, kableExtra)
#conflict_prefer_all("dplyr", quiet = TRUE)
walk(c("flextable","dplyr"), conflict_prefer_all, quiet = TRUE)

options(scipen = 999)
walk(c("Display_Functions","fun_alm","fun_indv_fit","fun_model"), ~ source(here::here(paste0("Functions/", .x, ".R"))))
```



### Modelling Results

```{r}
#| cache: false

ds <- readRDS(here::here("data/e1_md_11-06-23.rds"))  |> as.data.table()
nbins <- 3

fd <- readRDS(here("data/e1_08-21-23.rds"))
test <- fd |> filter(expMode2 == "Test") 
testAvg <- test %>% group_by(id, condit, vb, bandInt,bandType,tOrder) %>%
  summarise(nHits=sum(dist==0),vx=mean(vx),dist=mean(dist),sdist=mean(sdist),n=n(),Percent_Hit=nHits/n)

trainAvg <- fd |> filter(expMode2 == "Train") |> group_by(id) |> 
  mutate(tr=trial,x=vb,Block=case_when(expMode2=="Train" ~ cut(tr,breaks=seq(1,max(tr), length.out=nbins+1),include.lowest=TRUE,labels=FALSE),
                                         expMode2=="Test" ~ 4)) |> 
  group_by(id,condit,vb,x,Block) |> 
  summarise(dist=mean(dist),y=mean(vx))

input_layer <<- output_layer <<-  c(100,350,600,800,1000,1200)
ids2 <- c(1,66,36)
file_name <- "n_iter_200_ntry_300_5354"
#file_name <- "n_iter_400_ntry_100_2944"


ind_fits <- map(list.files(here(paste0('data/abc_reject/'),file_name),full.names=TRUE), readRDS)
ind_fits_df <- ind_fits |> map(~list(dat=.x[[1]], Model = .x[["Model"]], Fit_Method=.x[["Fit_Method"]]))
ind_fits_df <- ind_fits_df |> map(~rbindlist(.x$dat) |> mutate(Model = .x$Model, Fit_Method = .x$Fit_Method)) |> rbindlist() 
```

```{r}
#| cache: false

generate_data <- function(Model, post_samples, data, num_samples = 1, return_dat = "train_data, test_data") {
  # Filter data for the specific id without invalidating selfref
  sbj_data <- copy(data[id == post_samples$id[1]])
  simulation_function <- ifelse(Model == "EXAM", full_sim_exam, full_sim_alm)

  target_data <- switch(return_dat,
                        "test_data" = copy(sbj_data[expMode2 == "Test"]),
                        "train_data" = copy(sbj_data[expMode2 == "Train"]),
                        "train_data, test_data" = copy(sbj_data[expMode2 %in% c("Test", "Train")]))
  
  post_samples <- post_samples[order(mean_error)][1:num_samples, .(c, lr, mean_error, rank = .I)]

  simulated_data_list <- lapply(1:nrow(post_samples), function(i) {
    params <- post_samples[i]
    sim_data <- simulation_function(sbj_data, params$c, params$lr, input_layer = input_layer, 
                                    output_layer = output_layer, return_dat = return_dat)
    sim_data_dt <- data.table(id = sbj_data$id[1], condit = sbj_data$condit[1], 
                              expMode2 = target_data$expMode2, Model = Model,tr=target_data$tr,
                              y = target_data$y, x = target_data$x, c = params$c, 
                              lr = params$lr, mean_error = params$mean_error, rank = i,
                              pred = sim_data)
    return(sim_data_dt)
  })
  
  result_dt <- rbindlist(simulated_data_list)
  setcolorder(result_dt, c("id", "condit", "expMode2","tr", "c", "lr", "x", "y", "pred"))
  return(result_dt)
}

#future::plan(multisession)

nestSbjModelFit <- ind_fits_df %>% nest(.by=c(id,Model,Fit_Method))

# organize test data predictions
# post_dat <- nestSbjModelFit |> mutate(pp=furrr::future_pmap(list(id,Model,Fit_Method,data), ~{
#    generate_data(..2, ..4 |> mutate(id=..1), ds, num_samples = 50, return_dat="test_data")
#    })) |> 
#   select(Fit_Method,pp,-data) |>  
#   unnest(pp) |>  filter(expMode2=="Test") |> as.data.table()
# 
# saveRDS(post_dat, here("data/model_cache/post_dat.rds"))

post_dat <- readRDS(here("data/model_cache/post_dat.rds"))

post_dat_avg <- post_dat |> group_by(id, condit, Model, Fit_Method, x, c, lr, rank) |> 
  mutate(error2 = y - pred) |>
  summarise(y = mean(y), pred = mean(pred), error = y - pred, error2=mean(error2)) |> as.data.table()

setorder(post_dat_avg, id, x, rank)
post_dat_l <- melt(post_dat_avg, id.vars = c("id", "condit", "Model", "Fit_Method", "x", "c", "lr", "rank","error"),
                   measure.vars = c("pred", "y"), variable.name = "Resp", value.name = "val")
post_dat_l[, Resp := fifelse(Resp == "y", "Observed",
                             fifelse(Model == "ALM", "ALM", "EXAM"))]
setorder(post_dat_l, id, Resp)
#rm(post_dat_avg)

post_dat_l <- post_dat_l |> mutate(dist = case_when(
    val >= x & val <= x + 200 ~ 0,                 
    val < x ~ abs(x - val),                       
    val > x + 200 ~ abs(val - (x + 200)),           
    TRUE ~ NA_real_                                 
  ))


# organize training data predictions
# pd_train <- nestSbjModelFit |> mutate(pp=furrr::future_pmap(list(id,Model,Fit_Method,data), ~{
#    generate_data(..2, ..4 |> mutate(id=..1), ds, num_samples = 20, return_dat="train_data")
#    })) |>
#   select(Fit_Method,pp,-data) |>
#   unnest(pp) |> as.data.table() |> filter(expMode2=="Train")

#saveRDS(pd_train, here("data/model_cache/pd_train.rds"))

pd_train <- readRDS(here("data/model_cache/pd_train.rds"))

nbins <- 3
pd_train <- pd_train |> group_by(id,condit,Model,Fit_Method) |>
  mutate(Block=cut(tr,breaks=seq(1,max(tr), length.out=nbins+1),include.lowest=TRUE,labels=FALSE))
setorder(pd_train, id, x,Block, rank)

pd_train_l <- reshape2::melt(pd_train, id.vars = c("id", "condit", "Model","Block", "Fit_Method", "x", "c", "lr", "rank"),
                   measure.vars = c("pred", "y"), variable.name = "Resp", value.name = "val") |> as.data.table()
pd_train_l[, Resp := fifelse(Resp == "y", "Observed",
                             fifelse(Model == "ALM", "ALM", "EXAM"))] 
setorder(pd_train_l, id,Block, Resp) 

pd_train_l <- pd_train_l  |>
  mutate(dist = case_when(
    val >= x & val <= x + 200 ~ 0,                 
    val < x ~ abs(x - val),                       
    val > x + 200 ~ abs(val - (x + 200)),           
    TRUE ~ NA_real_                                 
  ))

#plan(sequential)

```

### Group level aggregations



```{r}
#| label: tbl-htw-modelError
#| tbl-cap: "Mean model errors predicting testing data, aggregated over all participants and velocity bands. Note that Fit Method refers to how model parameters were optimized, while error values reflect mean absolute error for the 6 testing bands"
#| tbl-subcap: 
#|   - "Cars"
#|   - "Pressure"
#| layout-ncol: 2

post_tabs <- abc_tables(post_dat,post_dat_l)
train_tab <- abc_train_tables(pd_train,pd_train_l)

t1 <- post_tabs$agg_pred_full |> 
  mutate(Fit_Method=rename_fm(Fit_Method)) |>
  flextable::tabulator(rows=c("Fit_Method","Model"), columns=c("condit"),
                       `ME` = as_paragraph(mean_error)) |> as_flextable()

#post_tabs$agg_pred_full |> pander::pandoc.table()

t2 <- train_tab$agg_pred_full |> 
  mutate(Fit_Method=rename_fm(Fit_Method)) |>
  flextable::tabulator(rows=c("Fit_Method","Model"), columns=c("condit"),
                       `ME` = as_paragraph(mean_error)) |> as_flextable() |> set_caption("f1")


t1
t2

```





## Markdown subtable


::: {#tbl-panel3334 layout-ncol=2}

`r t1`
: First Table {#tbl-first}


`r t2`
: Second Table {#tbl-second}

Main Caption
:::


```{r}
#| message: false
#| label: tbl-counts
#| tbl-pos: h
#| tbl-cap: "Mean model errors "
#| tbl-subcap:
#|   - "Full datasets"
#|   - "Intersection of samples with all labels available"
#| layout-ncol: 2
format_table <- function(tab) {
  tab %>%
    kable(format.args = list(big.mark = ',')) %>%
    kable_styling(font_size = 10)
}


post_tabs <- abc_tables(post_dat,post_dat_l)

# post_tabs$agg_pred_full |> 
#   mutate(Fit_Method=rename_fm(Fit_Method)) |>
#   flextable::tabulator(rows=c("Fit_Method","Model"), columns=c("condit"),
#                        `ME` = as_paragraph(mean_error)) |> as_flextable()

#post_tabs$agg_pred_full |> pander::pandoc.table()

post_tabs$agg_pred_full |> format_table()




# train_tab$agg_pred_full |> 
#   mutate(Fit_Method=rename_fm(Fit_Method)) |>
#   flextable::tabulator(rows=c("Fit_Method","Model"), columns=c("condit"),
#                        `ME` = as_paragraph(mean_error)) |> as_flextable()

train_tab$agg_pred_full |> format_table()

```

## pander

```{r}
#| label: tbl-example
#| tbl-cap: "Example"
#| tbl-subcap: 
#|   - "Cars"
#|   - "Pressure"
#| layout-ncol: 1

pander::pander(train_tab$agg_pred_full, caption="Train")
pander::pander(post_tabs$agg_pred_full, caption="Test")

```

## kbl

```{r}
#| label: tbl-dist-emmeans2b
#| tbl-cap: Conditional Means and Contrasts
#| tbl-subcap: ["Conditional Means", "Contrasts"]
#| layout-ncol: 2
post_tabs$agg_pred_full |> 
  kbl()

train_tab$agg_pred_full |> kbl()
```




## gt 

```{r}
#| label: tbl-dist-emmeans344
#| tbl-cap: Conditional Means and Contrasts
#| tbl-subcap: ["Conditional Means", "Contrasts"]
#| layout-ncol: 2



library(scales)
library(glue)
library(gt)
library(gtExtras)

gt_linebreak <- function(x) {
  if (fmt_out == "latex") {
    x %>% 
      str_replace_all("\\[", "{[}") %>% 
      str_replace_all("\\]", "{]}") %>% 
      kableExtra::linebreak(align = "c")
  } else {
    str_replace(x, "\\n", "<br>")
  }
}

fmt_markdown_latex <- function(x, columns) {
  if (fmt_out == "latex") {
    fmt_passthrough(x, columns = columns, escape = FALSE)
  } else {
    fmt_markdown(x, columns = columns)
  }
}

gt_pct <- function(x, page_width = 6) {
  if (knitr::pandoc_to("latex")) {
    paste0(page_width * (x / 100), "in")
  } else {
    gt::pct(x)
  }
}

post_tabs$agg_pred_full |> gt() |> tab_style(
    style = cell_text(v_align = "top"),
    locations = cells_body()
  ) %>%
  tab_options(
    quarto.disable_processing = FALSE
  )


train_tab$agg_pred_full |> gt() |> tab_style(
    style = cell_text(v_align = "top"),
    locations = cells_body()
  ) %>%
  tab_options(
    quarto.disable_processing = FALSE
  )

```


## Markdown subtable


::: {#tbl-panel layout-ncol=2}
| Col1 | Col2 | Col3 |
|------|------|------|
| A    | B    | C    |
| E    | F    | G    |
| A    | G    | G    |

: First Table {#tbl-first}

| Col1 | Col2 | Col3 |
|------|------|------|
| A    | B    | C    |
| E    | F    | G    |
| A    | G    | G    |

: Second Table {#tbl-second}

Main Caption
:::


```{r}
#| label: tbl-dist-emmea7
#| tbl-cap: Conditional Means and Contrasts
#| tbl-subcap: ["Conditional Means", "Contrasts"]
#| layout-ncol: 2

train_tab$agg_pred_full |> pander::pandoc.table()
post_tabs$agg_pred_full |> pander::pandoc.table()
```


```{r}
#| label: tbl-dist-emmeans5
#| tbl-cap: Conditional Means and Contrasts
#| tbl-subcap: ["Conditional Means", "Contrasts"]
#| layout-ncol: 2

train_tab$agg_pred_full |> pander::pandoc.table(style="grid", caption="test cap1")
post_tabs$agg_pred_full |> pander::pandoc.table(style="grid")
```



```{r}
#| label: tbl-dist-emmeans4
#| tbl-cap: Conditional Means and Contrasts
#| tbl-subcap: ["Conditional Means", "Contrasts"]
#| layout-ncol: 2

train_tab$agg_pred_full |> pander::pandoc.table(style="rmarkdown", caption="test cap1")
post_tabs$agg_pred_full |> pander::pandoc.table(style="rmarkdown", caption="test cap2")

```


```{r}

# format_dataframe <- function(df) {
#   df_split <- split(df, df$Group)
#   pander_return <- pander::pandoc.table.return(TRUE)
#   tables <- lapply(df_split, function(x) {
#    # x$Group <- NULL  # Remove the Group column since it's already used for splitting
#     pander(x, style = 'rmarkdown', split.table = Inf)
#   })
#   pander::pandoc.table.return(pander_return)
#   return(tables)
# }
# 
# formatted_tables <- format_dataframe(train_tab$agg_pred_full )
# 
# for (table in formatted_tables) {
#   cat(table, sep = '\n\n')
# }





```


