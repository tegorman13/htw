---
title: "rbf.qmd"
jupyter: julia-1.9
---

```{r}
pacman::p_load(tidyverse,RSNNS,tikzDevice,knitr)
```

```{r fig.width=11, fig.height=9}
#| eval: false 
n_iter=500
n_nodes <- c(c(1,2,3,4,5,6,7,8,9),seq(10,300,20))
test <- tibble(input=as.matrix(seq(0,100,1)),output=as.matrix(round(2.2*input + 30,0)))
train <- tibble(input=as.matrix(seq(30,70,5)),output=as.matrix(round(2.2*input + 30,0)))


fits <- map(n_nodes,~rbf(train$input,train$output,size=.x,maxit=n_iter))
pred <- map(fits,~predict(.x,test$input))

predGrid <- crossing(n_nodes,test) %>% 
  cbind(.,pred=unlist(pred))

fitGrid <- crossing(n_nodes,train) %>% 
  cbind(.,fit=unlist(map(fits,fitted))) |>
  mutate(resid=output-fit)

fitGrid |> ggplot(aes(input,output))+geom_point()+geom_point(aes(x=input,y=fit),col="green")+facet_wrap(~n_nodes,scales="free")

predGrid |> ggplot(aes(input,output))+geom_point()+geom_point(aes(x=input,y=pred),col="green")+facet_wrap(~n_nodes,scales="free")


crossing(n_nodes,train) %>% 
  cbind(.,fit=unlist(map(fits,fitted))) %T>% 
  {print(ggplot(d,aes(x=input,y=output))+geom_line()+
  geom_line(aes(x=input,y=fit),col="green") + facet_wrap(~n_nodes,scales="free")) } %>% 
  {. ->> d}
  
tibble(n_nodes=as.factor(rep(n_nodes,each=n_iter))) %>% 
  cbind(.,error=unlist(purrr::map(fits, ~.x$IterativeFitError))) %>%
  mutate(it=seq(1,n()),.by=n_nodes) %T>% 
  {print(ggplot(.,aes(it,error,col=n_nodes))+geom_line()+facet_wrap(~n_nodes,scales="free")) } %>% 
  {. ->> errVec}


preds <- map(fits,~predict(.x,as.matrix(seq(0,150,1))))

tibble(n_nodes=n_nodes,fit=map(fits,~predict(.x,as.matrix(seq(0,150,1)))))

tibble(n_nodes=rep(n_nodes,each=150),input=as.matrix(seq(0,150,1)),output=as.matrix(round(2.2*input + 30,0)))

```





```{r}
#| echo: false
#| eval: false 

# d <- crossing(n_nodes,train) %>% 
#   cbind(.,fit=unlist(map(fits,fitted)))

# purrr::map(fits, ~.x$IterativeFitError)
# unlist(purrr::map(fits, ~.x$IterativeFitError))

inputs <- as.matrix(seq(0,100,1))
outputs <- as.matrix(round(2.2*inputs + 30,0))

model <- rbf(inputs, outputs, size=10, maxit=5000,
                     initFuncParams=c(0, 1, 0, 0.01, 0.01),
                     learnFuncParams=c(1e-8, 0, 1e-8, 0.1, 0.8), linOut=TRUE)

ggplot(d,aes(x=input,y=output))+geom_line()+
  geom_line(aes(x=input,y=fit),col="green") + facet_wrap(~n_nodes,scales="free")


inputs <- as.matrix(seq(0,10,0.1))
outputs <- as.matrix(sin(inputs) + runif(inputs*0.2))
outputs <- normalizeData(outputs, "0_1")

model <- rbf(inputs, outputs, size=40, maxit=1000,
                     initFuncParams=c(0, 1, 0, 0.01, 0.01),
                     learnFuncParams=c(1e-8, 0, 1e-8, 0.1, 0.8), linOut=TRUE)

par(mfrow=c(2,1))
plotIterativeError(model)
plot(inputs, outputs)
lines(inputs, fitted(model), col="green")
```

```{r}

library("RSNNS")
train_data <- dat[dat$expMode2 == "Train", ]
train_2nd<- train_data[round(nrow(train_data)/2):nrow(train_data),]
test_data <- dat[dat$expMode2 == "Test", ]
test_avg <- test_data |> group_by(x) |> summarise(y=mean(y))

rbfn.model <- RSNNS::rbf(as.matrix(ds$x),
                         as.matrix(ds$y),
                         size=c(12),    # number of centers, ie, number of neurons in hidden layer
                         maxit=100, # max number of iterations to learn
                         linOut=TRUE) # linear activation function (otherwise logistic)

rbf.network.pred <- predict(rbfn.model,as.matrix(test_avg$x))  # apply sign, since this is a classification eg
plotIterativeError(rbfn.model)




elman.model <- RSNNS::elman(as.matrix(train_data$x),
                         as.matrix(train_data$y),
                         size=c(3,9,3),
                         learnFuncParams = c(.01),
                         inputsTest=as.matrix(test_avg$x), targetsTest = as.matrix(test_avg$y),
                         maxit=1000, # max number of iterations to learn
                         linOut=TRUE) # linear activation function (otherwise logistic)
predict(elman.model,as.matrix(test_avg$x))
plotIterativeError(elman.model)
plotRegressionError(test_avg$x, elman.model$fittedTestValues)

#
mlp.model <- RSNNS::mlp(as.matrix(test_data$x),
                            as.matrix(test_data$y),
                            size=c(4,2),
                            learnFuncParams = c(.001),
                            inputsTest=as.matrix(test_avg$x), targetsTest = as.matrix(test_avg$y),
                            maxit=10, # max number of iterations to learn
                            linOut=TRUE) # linear activation function (otherwise logistic)
predict(mlp.model,as.matrix(test_avg$x))
plotIterativeError(mlp.model)
plotRegressionError(test_avg$x, mlp.model$fittedTestValues)

som.model <- RSNNS::som(
                        as.matrix(ds$y),
                        mapX=3,
                        mapY=3,
                         targets = as.matrix(test_avg$y),
                        maxit=100, # max number of iterations to learn
                        linOut=TRUE) # linear activation function (otherwise logistic)
predict(som.model,as.matrix(test_avg$x))
plotIterativeError(mlp.model)
plotRegressionError(test_avg$x, mlp.model$fittedTestValues)

plotActMap(som.model$map, col = rev(heat.colors(12)))
plotActMap(som.model$labeledMap)

som.model$map
som.model$componentMaps
som.model$labeledMap
som.model$componentMaps
som.model$labeledUnits


```

