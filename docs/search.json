[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HTW Project",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Categories\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nModeling\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling\n\n\nALM\n\n\nR\n\n\nBayesian\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#modeling-empircal-data",
    "href": "index.html#modeling-empircal-data",
    "title": "HTW Project",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Categories\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nModeling\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling\n\n\nALM\n\n\nR\n\n\nBayesian\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#simulations",
    "href": "index.html#simulations",
    "title": "HTW Project",
    "section": "Simulations",
    "text": "Simulations\n\n\n\n\n\n\n\n\nALM Learning\n\n\n\nSimulation\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nBenchmarking\n\n\n\nSimulation\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nGeneral Simulations\n\n\n\nSimulation\n\n\nALM\n\n\nEXAM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nNode Manipulations\n\n\n\nSimulation\n\n\nALM\n\n\nR\n\n\nModel-Structure\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nNoisy Learning\n\n\n\nSimulation\n\n\nALM\n\n\nR\n\n\nBayesian\n\n\nModel-Structure\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Recovery Simulations\n\n\n\nSimulation\n\n\nALM\n\n\nEXAM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nSimulating DeLosh 1997\n\n\n\nSimulation\n\n\nALM\n\n\nEXAM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nlearning bias\n\n\n\nSimulation\n\n\nALM\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#analyses",
    "href": "index.html#analyses",
    "title": "HTW Project",
    "section": "Analyses",
    "text": "Analyses\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Categories\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nHTW Analysis\n\n\n\nAnalysis\n\n\nLearning-Curve\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nHTW Test Analysis\n\n\n\nAnalysis\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nME_Pool\n\n\n\nAnalysis\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nOJS data exploration\n\n\n\nAnalysis\n\n\nLearning-Curve\n\n\nR\n\n\nOJS\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nTesting Discrimination Analysis\n\n\n\nAnalysis\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#misc",
    "href": "index.html#misc",
    "title": "HTW Project",
    "section": "Misc",
    "text": "Misc\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Categories\n        \n     \n  \n\n\n\n\n\n\n\n\nALM Shiny App Code\n\n\n\nSimulation\n\n\nALM\n\n\nEXAM\n\n\nShiny\n\n\nInteractive\n\n\nR\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nHTW Task\n\n\n\nTask\n\n\njs\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\nMermaid with R + consort\n\n\n\nVisualization\n\n\nR\n\n\nOJS\n\n\n\n\n\n\n\n\n\n\nJun 2023\n\n\n\n\n\n\n\n\n\n\n\n\nModel Visualization\n\n\n\nVisualization\n\n\nR\n\n\nOJS\n\n\n\n\n\n\n\n\n\n\nJun 2023\n\n\n\n\n\n\n\n\n\n\n\n\nOJS ALM\n\n\n\nSimulation\n\n\nALM\n\n\nOJS\n\n\nInteractive\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOJS data exploration\n\n\n\nAnalysis\n\n\nLearning-Curve\n\n\nR\n\n\nOJS\n\n\n\n\n\n\n\n\n\n\nMay 2023\n\n\n\n\n\n\n\n\n\n\n\n\ntikz\n\n\n\nVisualization\n\n\nR\n\n\nOJS\n\n\n\n\n\n\n\n\n\n\nJun 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Visuals_Interactives/model_viz.html",
    "href": "Visuals_Interactives/model_viz.html",
    "title": "Model Visualization",
    "section": "",
    "text": "Code\n#lapply(c('tidyverse','data.table','igraph','ggraph','kableExtra'),library,character.only=TRUE))\npacman::p_load(tidyverse,data.table,igraph,ggraph,kableExtra,DiagrammeR,png, plantuml)"
  },
  {
    "objectID": "Visuals_Interactives/model_viz.html#ggplot-model-visualization",
    "href": "Visuals_Interactives/model_viz.html#ggplot-model-visualization",
    "title": "Model Visualization",
    "section": "ggplot model visualization",
    "text": "ggplot model visualization\n\n\nCode\nnInput=6\nnOutput=10\n\ninNodes &lt;- seq(1,nInput,1) %&gt;% as.integer()\noutNodes &lt;- seq(300,1000,length.out=nOutput)%&gt;% as.integer()\nweight.mat &lt;&lt;- matrix(0.001,nrow=nOutput,ncol=nInput) # weights initialized to 0 (as in Delosh 1997)\n\nstim &lt;- 1.5\nc=.1\ninAct &lt;- round(exp(-c*((inNodes-stim)^2)),2)\ninActLab &lt;- paste0(\"x\",inNodes,\"=\",inAct)\noutAct &lt;- weight.mat %*% inAct\noutput.probability &lt;&lt;- outAct/sum(outAct)\noutLab=paste0(\"y\",outNodes,\"=\",round(output.probability,2))\nmean.response &lt;&lt;- round(sum(outNodes * output.probability),0)\n\n\nresp &lt;- mean.response\ninFlow &lt;- tibble(expand.grid(from=stim,to=inActLab)) %&gt;% mutate_all(as.character)\noutFlow &lt;- tibble(expand.grid(from=outLab,to=mean.response)) %&gt;% mutate_all(as.character)\n\ngd &lt;- tibble(expand.grid(from=inActLab,to=outLab)) %&gt;% mutate_all(as.character) %&gt;%\n  rbind(inFlow,.) %&gt;% rbind(.,outFlow)\n\nxInc &lt;- .3\nyInc=.5\n\ng = graph_from_data_frame(gd,directed=TRUE)\ncoords2=layout_as_tree(g)\ncolnames(coords2)=c(\"y\",\"x\")\n\nodf &lt;- as_tibble(coords2) %&gt;% \n  mutate(label=vertex_attr(g,\"name\"),\n         type=c(\"stim\",rep(\"Input\",nInput),rep(\"Output\",nOutput),\"Resp\"),\n         x=x*-1) %&gt;%\n  mutate(y=ifelse(type==\"Resp\",0,y),xmin=x-xInc,xmax=x+xInc,ymin=y-yInc,ymax=y+yInc)\n\nplot_edges = gd %&gt;% mutate(id=row_number()) %&gt;%\n  pivot_longer(cols=c(\"from\",\"to\"),names_to=\"s_e\",values_to=(\"label\")) %&gt;%\n                 mutate(label=as.character(label)) %&gt;% \n  group_by(id) %&gt;%\n  mutate(weight=sqrt(rnorm(1,mean=0,sd=10)^2)/10) %&gt;%\n  left_join(odf,by=\"label\") %&gt;%\n  mutate(xmin=xmin+.02,xmax=xmax-.02)\n\nggplot() + geom_rect(data = odf,\n            mapping = aes(xmin = xmin, ymin = ymin, \n                          xmax = xmax, ymax = ymax, \n                          fill = type, colour = type),alpha = 0.01) +\n  geom_text(data=odf,aes(x=x,y=y,label=label,size=3)) +\n  geom_path(data=plot_edges,mapping=aes(x=x,y=y,group=id,alpha=weight)) +\n  # geom_rect(aes(xmin=-1.05,xmax=-.95,ymin=-10,ymax=5),color=\"red\",alpha=.1)+\n  # geom_rect(aes(xmin=-0.05,xmax=.05,ymin=-10,ymax=5),color=\"blue\",alpha=.1) +\n  theme_void()"
  },
  {
    "objectID": "Visuals_Interactives/model_viz.html#ggraph-method",
    "href": "Visuals_Interactives/model_viz.html#ggraph-method",
    "title": "Model Visualization",
    "section": "ggraph method",
    "text": "ggraph method\n\n\nCode\ninNodes &lt;- seq(1,6,1) %&gt;% as.integer()\noutNodes &lt;- seq(300,1000,50)%&gt;% as.integer()\n\nda &lt;- data.frame(expand.grid(inNodes,outNodes))  %&gt;% magrittr::set_colnames(c(\"input\",\"output\"))\nda &lt;- da %&gt;% mutate_all(as.character)\nm = graph_from_data_frame(da, directed = TRUE)\n\ncoords = layout_with_sugiyama(m)\ncolnames(coords$layout) = c(\"y\", \"x\")\ncoords$layout=coords$layout[,c(\"x\",\"y\")]\nplot(m,layout=coords)\n\n\n\n\n\nCode\nggraph(m,layout=coords$layout)+\ngeom_edge_link0(width=0.2,colour=\"grey\")+\n  geom_node_point(col=\"white\",size=6)+scale_x_reverse()+\n  geom_node_text(aes(label=name)) +\n  # draw rectangle that covers input layer at x=1, min y is min of coords$y and max y is max of coords$y\n  annotate(\"rect\",xmin=0,xmax=.1,ymin=min(coords$layout[,2]),ymax=max(coords$layout[,2]),fill=\"grey\",alpha=0.7)\n\n\n\n\n\nCode\n geom_rect(xmin=0,xmax=1.1,ymin=min(coords$layout[,2]),ymax=max(coords$layout[,2]),fill=\"grey\",alpha=0.7)\n\n\ngeom_rect: linejoin = mitre, na.rm = FALSE\nstat_identity: na.rm = FALSE\nposition_identity \n\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(ggforce)\n\ntheme_set(theme_grey() +\n            theme_void() +\n            theme(plot.margin = margin(0, 5.5, 0, 5.5)))\n\n# Parameters\ninput_x &lt;- c(1, 2)\noutput_x &lt;- c(1.5, 2.5, 3.5)\ninput_y &lt;- 3\noutput_y &lt;- 1\nactivation_levels &lt;- c(0.2, 0.7, 0.5)\n\n# Input Layer\ninput_layer &lt;- tibble(x = input_x, y = rep(input_y, length(input_x)))\n\n# Output Layer\noutput_layer &lt;- tibble(x = output_x, y = rep(output_y, length(output_x)), activation = activation_levels)\n\n# Gaussian Activation\ngaussian_activation &lt;- tibble(\n  x = seq(from = 0, to = 3, by = 0.01),\n  y = exp(-2 * (x - 1)^2) + 2.5,\n  x2 = x,\n  y2 = exp(-2 * (x - 2)^2) + 2.5\n)\n\n# Plot\np &lt;- ggplot() +\n  # Input nodes\n  geom_point(data = input_layer, aes(x = x, y = y), size = 4, color = 'green') +\n  annotate(\"text\", x = input_x, y = rep(input_y, length(input_x)) + 0.3, label = c(\"Input #1\", \"Input #2\")) +\n  \n  # Gaussian Activations\n  geom_line(data = gaussian_activation, aes(x = x, y = y), color = 'blue') +\n  geom_line(data = gaussian_activation, aes(x = x2, y = y2), color = 'blue') +\n  \n  # Connections\n  geom_segment(data = expand.grid(input_x, output_x), aes(x = Var1, xend = Var2, y = input_y, yend = output_y), arrow = arrow(type = 'closed', length = unit(0.2, 'inches'))) +\n  \n  # Output nodes\n  geom_point(data = output_layer, aes(x = x, y = y), size = 4, color = 'red') +\n  geom_bar(data = output_layer, aes(x = x, y = activation), stat = 'identity', position = 'dodge', fill = 'red', alpha = 0.3, width = 0.3) +\n  annotate(\"text\", x = output_x, y = rep(output_y, length(output_x)) - 0.3, label = c(\"Output #1\", \"Output #2\", \"Output #3\")) +\n  \n  # Equation annotations\n  annotate(\"text\", x = 0.5, y = input_y + 1, label = \"1\", parse = TRUE) +\n  annotate(\"text\", x = 1.5, y = output_y - 1, label = \"2 \", parse = TRUE) +\n  \n  # Input stimulus and output response\n  annotate(\"text\", x = mean(input_x), y = input_y + 1.3, label = \"Input Stimulus\") +\n  annotate(\"text\", x = mean(output_x), y = output_y - 1.3, label = \"Output Response\") +\n  \n  # Coordinate limits and axis labels\n  coord_cartesian(xlim = c(0, 4), ylim = c(-1, 5)) +\n  labs(x = \"\", y = \"\") +\n  theme_void()\n\n# Show the plot\nprint(p)\n\n\n\n\n\n\n\nCode\n# Load the required libraries\nlibrary(ggplot2)\nlibrary(ggpp)\nlibrary(tidyverse)\nlibrary(patchwork)\n\n# Create the Gaussian curve plots for each input node\ninput_node_1 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 1, sd = .4)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\ninput_node_2 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 2, sd = .4)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\ninput_node_3 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 3, sd = .4)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\n# Create the main plot\nmain_plot &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"plot_npc\", npcx = 0.2, npcy = 0.8, label = input_node_1) +\n  annotate(\"plot_npc\", npcx = 0.5, npcy = 0.8, label = input_node_2) +\n  annotate(\"plot_npc\", npcx = 0.8, npcy = 0.8, label = input_node_3) +\n  annotate(\"text\", x = 0.2, y = 0.7, label = \"Input Node 1\") +\n  annotate(\"text\", x = 0.5, y = 0.7, label = \"Input Node 2\") +\n  annotate(\"text\", x = 0.8, y = 0.7, label = \"Input Node 3\") +\n  annotate(\"text\", x = 0.5, y = 0.6, label = \"Input Layer\", fontface = \"bold\") +\n  annotate(\"text\", x = 0.5, y = 0.3, label = \"Output Layer\", fontface = \"bold\") +\n  annotate(\"text\", x = 0.5, y = 0.1, label = \"ALM + EXAM Response\", fontface = \"bold\")\n\n# Print the main plot\nprint(main_plot)\n\n\n\n\n\n# Create the Gaussian curve plots for each input node\ninput_node_1 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\ninput_node_2 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 2.2, sd = 1)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\ninput_node_3 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 4.3, sd = .1)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\n# Create the main plot\nmain_plot &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"plot_npc\", npcx = 0.2, npcy = 0.8, label = input_node_1, width = 0.1, height = 0.1) +\n  annotate(\"plot_npc\", npcx = 0.5, npcy = 0.8, label = input_node_2, width = 0.1, height = 0.1) +\n  annotate(\"plot_npc\", npcx = 0.8, npcy = 0.8, label = input_node_3, width = 0.1, height = 0.1) +\n  annotate(\"text\", x = 0.2, y = 0.9, label = \"Input Node 1\") +\n  annotate(\"text\", x = 0.5, y = 0.9, label = \"Input Node 2\") +\n  annotate(\"text\", x = 0.8, y = 0.9, label = \"Input Node 3\") +\n  annotate(\"text\", x = 0.5, y = 0.6, label = \"Input Layer\", fontface = \"bold\") +\n  annotate(\"rect\", xmin = 0.1, xmax = 0.3, ymin = 0.4, ymax = 0.5, fill = \"grey80\") +\n  annotate(\"rect\", xmin = 0.4, xmax = 0.6, ymin = 0.4, ymax = 0.5, fill = \"grey80\") +\n  annotate(\"rect\", xmin = 0.7, xmax = 0.9, ymin = 0.4, ymax = 0.5, fill = \"grey80\") +\n  annotate(\"text\", x = 0.5, y = 0.3, label = \"Output Layer\", fontface = \"bold\") +\n  annotate(\"text\", x = 0.5, y = 0.1, label = \"ALM + EXAM Response\", fontface =\"bold\")\nprint(main_plot)\n\n\n# Create the Gaussian curve plots for each input node\ninput_node_1 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 0, sd = .41)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  ggtitle(\"Input Node 1\")\n\ninput_node_2 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 2, sd = .41)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  ggtitle(\"Input Node 2\")\n\ninput_node_3 &lt;- ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n  stat_function(fun = dnorm, args = list(mean = 3, sd = .41)) +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  ggtitle(\"Input Node 3\")\n\n# Create the output nodes\noutput_node_1 &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"rect\", xmin = -1, xmax = 1, ymin = -1, ymax = 1, fill = \"blue\") +\n  ggtitle(\"Output Node 1\")\n\noutput_node_2 &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"rect\", xmin = -1, xmax = 1, ymin = -1, ymax = 1, fill = \"blue\") +\n  ggtitle(\"Output Node 2\")\n\n# Combine the input and output nodes using patchwork\ninput_layer &lt;- input_node_1 + input_node_2 + input_node_3\noutput_layer &lt;- output_node_1 + output_node_2\n\n# Create the connection matrix\nconnection_matrix &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"segment\", x = 0.2, xend = 0.8, y = 0.8, yend = 0.2, arrow = arrow()) +\n  annotate(\"segment\", x = 0.5, xend = 0.8, y = 0.8, yend = 0.2, arrow = arrow()) +\n  annotate(\"segment\", x = 0.8, xend = 0.8, y = 0.8, yend = 0.2, arrow = arrow())\n\n# Combine the input layer, connection matrix, and output layer\nmain_plot &lt;- input_layer / connection_matrix / output_layer\n\n# Print the main plot\nprint(main_plot)\n\n\n\n\n\n\n# Function to create an input node\ncreate_input_node &lt;- function(mean, position) {\n  ggplot(data.frame(x = seq(-3, 3, length.out = 100)), aes(x)) +\n    stat_function(fun = dnorm, args = list(mean = mean, sd = .3)) +\n    theme_void() +\n    theme(plot.margin = margin(0, 0, 0, 0)) +\n    coord_cartesian(xlim = c(0, 3), ylim = c(0, 0.5)) + coord_flip()+\n    labs(title = paste(\"Input Node\", position)) +\n    theme(plot.title = element_text(hjust = 0.5))\n}\n\n# Function to create an output node\ncreate_output_node &lt;- function(position) {\n  ggplot() +\n    theme_void() +\n    theme(plot.margin = margin(0, 0, 0, 0)) +\n    annotate(\"rect\", xmin = -1, xmax = 1, ymin = -1, ymax = 1, fill = \"grey80\") +\n    labs(title = paste(\"Output Node\", position)) +\n    theme(plot.title = element_text(hjust = 0.5))\n}\n\ncreate_input_layer &lt;- function(n) {\n  input_plots &lt;- map(1:n, ~create_gaussian_plot(.x))\n  input_layer &lt;- wrap_plots(input_plots, ncol = 1) + coord_flip()\n  return(input_layer)\n}\n\n\n\n# Create the input nodes\ninput_nodes &lt;- map(1:3, ~create_input_node(.x, .x))\n\n# Create the output nodes\noutput_nodes &lt;- map(1:4, ~create_output_node(.x))\n\n## Create the connection matrix\nconnection_matrix &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"segment\", x = 1, xend = 2, y = rep(1:3, each = 4), yend = rep(1:4, times = 3), arrow = arrow())\n# Combine the plots\ninput_layer &lt;- wrap_plots(input_nodes,byrow=FALSE,ncol=1)\noutput_layer &lt;- wrap_plots(output_nodes, ncol = 1)\nmain_plot &lt;- input_layer + connection_matrix + output_layer + plot_layout(ncol = 3)\n\n# Print the main plot\nprint(main_plot)\n\n\n\n\n\ncombined_plot &lt;- input_layer + connection_matrix + output_layer +\n  plot_layout(ncol = 3)\n\nprint(combined_plot)\n\n\n\nprint(input_layer)\n\n\n\n\nCode\n# Load the required libraries\nlibrary(ggplot2)\nlibrary(ggpp)\nlibrary(patchwork)\nlibrary(tidyverse)\n\n# Function to create the input layer\ncreate_input_layer &lt;- function(n_nodes, stimulus = 0, gamma = 5) {\n  # Create a data frame with the x values and node means\n  df &lt;- expand.grid(x = seq(-3, 3, length.out = 100),\n                    mean = seq(-2, 1.5, length.out = n_nodes)) %&gt;% \n    mutate(noisyMean=map(mean,~dnorm(.x,mean,sd=.5)))\n  \n  df &lt;- df %&gt;%\n    mutate(distance = abs(x - stimulus),\n           noise = rnorm(n(), sd = 0.05),\n           max_activation = exp(-gamma * distance^2) + noise,\n           y = max_activation * exp(-gamma * (x - mean)^2))\n  \n  # Create the plot\n  ggplot(df, aes(x, y, group = mean)) +\n    geom_line() +\n    geom_smooth()+\n    coord_cartesian(xlim = c(-2, 2), ylim = c(0, 1)) +\n    labs(title = \"Input Layer\") +\n    theme(plot.title = element_text(hjust = 0.5))\n}\n\n# Function to create an output node\ncreate_output_node &lt;- function(position) {\n  ggplot() +\n    theme_void() +\n    theme(plot.margin = margin(0, 0, 0, 0)) +\n    annotate(\"rect\", xmin = -1, xmax = 1, ymin = -1, ymax = 1, fill = \"grey80\") +\n    labs(title = paste(\"Output Node\", position)) +\n    theme(plot.title = element_text(hjust = 0.5))\n}\n\n# Create the input layer\ninput_layer &lt;- create_input_layer(3)\n\n# Create the output nodes\noutput_nodes &lt;- map(1:4, ~create_output_node(.x))\n\n# Create the connection matrix\nconnection_matrix &lt;- ggplot() +\n  theme_void() +\n  theme(plot.margin = margin(0, 0, 0, 0)) +\n  annotate(\"segment\", x = 1, xend = 2, y = 1:3, yend = rep(1:4, each = 3), arrow = arrow())\n\n# Combine the plots\noutput_layer &lt;- wrap_plots(output_nodes, ncol = 1)\nmain_plot &lt;- input_layer + connection_matrix + output_layer + plot_layout(ncol = 3)\n\n# Print the main plot\nprint(main_plot)\n\n\n\n\nCode\n# Load the visNetwork package\nlibrary(visNetwork)\n\n# Define the nodes\nnodes &lt;- data.frame(\n  id = c(\"InputLayer\", \"I1\", \"I2\", \"I3\", \"OutputLayer\", \"O1\", \"O2\", \"O3\", \"O4\", \"ALM\", \"EXAM\"),\n  label = c(\"Input Layer\", \"Input Node 1\", \"Input Node 2\", \"Input Node 3\", \"Output Layer\", \"Output Node 1\", \"Output Node 2\", \"Output Node 3\", \"Output Node 4\", \"ALM Response\", \"EXAM Response\"),\n  shape = c(\"box\", \"image\", \"image\", \"image\", \"box\", \"circle\", \"circle\", \"circle\", \"circle\", \"box\", \"box\"),\n  image = c(NA, \"gaussian_curve_input_node_1.png\", \"gaussian_curve_input_node_2.png\", \"gaussian_curve_input_node_3.png\", NA, NA, NA, NA, NA, NA, NA)\n)\n\n# Define the edges\nedges &lt;- data.frame(\n  from = c(\"InputLayer\", \"I1\", \"I1\", \"I1\", \"I1\", \"I2\", \"I2\", \"I2\", \"I2\", \"I3\", \"I3\", \"I3\", \"I3\", \"OutputLayer\", \"OutputLayer\", \"ALM\", \"EXAM\"),\n  to = c(\"I1\", \"O1\", \"O2\", \"O3\", \"O4\", \"O1\", \"O2\", \"O3\", \"O4\", \"O1\", \"O2\", \"O3\", \"O4\", \"ALM\", \"EXAM\", \"EXAM\", \"ALM\"),\n  label = c(\"\", \"w1\", \"w2\", \"w3\", \"w4\", \"w5\", \"w6\", \"w7\", \"w8\", \"w9\", \"w10\", \"w11\", \"w12\", \"\", \"\", \"Pure ALM Model\", \"ALM with EXAM Response Component\")\n)\n\n# Create the network diagram\nvisNetwork(nodes, edges, width = \"100%\") %&gt;%\n  visNodes(shapeProperties = list(useBorderWithImage = TRUE)) %&gt;%\n  visLayout(randomSeed = 2)\n\n\n\n\n\n\nCode\n# Define the nodes\nnodes &lt;- data.frame(\n  id = c(\"InputLayer\", \"I1\", \"I2\", \"I3\", \"OutputLayer\", \"O1\", \"O2\", \"O3\", \"O4\", \"ALM\", \"EXAM\"),\n  label = c(\"Input Layer\", \"&lt;img src='gaussian_curve_input_node_1.png' /&gt;\", \"&lt;img src='gaussian_curve_input_node_2.png' /&gt;\", \"&lt;img src='gaussian_curve_input_node_3.png' /&gt;\", \"Output Layer\", \"Output Node 1\", \"Output Node 2\", \"Output Node 3\", \"Output Node 4\", \"ALM Response\", \"EXAM Response\"),\n  shape = c(\"box\", \"circle\", \"circle\", \"circle\", \"box\", \"circle\", \"circle\", \"circle\", \"circle\", \"box\", \"box\")\n)\n\n# Define the edges\nedges &lt;- data.frame(\n  from = c(\"InputLayer\", \"I1\", \"I1\", \"I1\", \"I1\", \"I2\", \"I2\", \"I2\", \"I2\", \"I3\", \"I3\", \"I3\", \"I3\", \"OutputLayer\", \"OutputLayer\", \"ALM\", \"EXAM\"),\n  to = c(\"I1\", \"O1\", \"O2\", \"O3\", \"O4\", \"O1\", \"O2\", \"O3\", \"O4\", \"O1\", \"O2\", \"O3\", \"O4\", \"ALM\", \"EXAM\", \"EXAM\", \"ALM\"),\n  label = c(NA, \"w1\", \"w2\", \"w3\", \"w4\", \"w5\", \"w6\", \"w7\", \"w8\", \"w9\", \"w10\", \"w11\", \"w12\", NA, NA, \"Pure ALM Model\", \"ALM with EXAM Response Component\")\n)\n\n# Create the network diagram\nvisNetwork(nodes, edges, width = \"100%\") %&gt;%\n  visNodes(shapeProperties = list(useBorderWithImage = TRUE)) %&gt;%\n  visLayout(randomSeed = 2)\n\n\n\n\n\n\n\n\nCode\n# Load the DiagrammeR package\nlibrary(DiagrammeR)\n# Define the graph\ngrViz(\"\n  digraph ALM_EXAM {\n\n    # Graph attributes\n    graph [overlap = true, fontsize = 10]\n\n    # Node definitions\n    node [shape = box, fontname = Helvetica]\n    InputLayer [label = 'Input Layer']\n    OutputLayer [label = 'Output Layer']\n    ALM [label = 'ALM Response']\n    EXAM [label = 'EXAM Response']\n\n    node [shape = circle, fixedsize = true, width = 0.9]\n    I1 [label = 'Input Node 1']\n    I2 [label = 'Input Node 2']\n    I3 [label = 'Input Node 3']\n    O1 [label = 'Output Node 1']\n    O2 [label = 'Output Node 2']\n    O3 [label = 'Output Node 3']\n    O4 [label = 'Output Node 4']\n\n    # Edge definitions\n    InputLayer -&gt; I1\n    InputLayer -&gt; I2\n    InputLayer -&gt; I3\n    I1 -&gt; O1 [label = 'w1']\n    I1 -&gt; O2 [label = 'w2']\n    I1 -&gt; O3 [label = 'w3']\n    I1 -&gt; O4 [label = 'w4']\n    I2 -&gt; O1 [label = 'w5']\n    I2 -&gt; O2 [label = 'w6']\n    I2 -&gt; O3 [label = 'w7']\n    I2 -&gt; O4 [label = 'w8']\n    I3 -&gt; O1 [label = 'w9']\n    I3 -&gt; O2 [label = 'w10']\n    I3 -&gt; O3 [label = 'w11']\n    I3 -&gt; O4 [label = 'w12']\n    OutputLayer -&gt; O1\n    OutputLayer -&gt; O2\n    OutputLayer -&gt; O3\n    OutputLayer -&gt; O4\n    OutputLayer -&gt; ALM\n    OutputLayer -&gt; EXAM\n    ALM -&gt; EXAM [label = 'Pure ALM Model']\n    EXAM -&gt; ALM [label = 'ALM with EXAM Response Component']\n  }\n\")\n\n\n\n\n\n\n\n\nCode\n# Load the required packages\nlibrary(ggplot2)\nlibrary(png)\n\n# Define the Gaussian function\ngaussian &lt;- function(x, mean, sd) {\n  1/(sd*sqrt(2*pi)) * exp(-1/2 * ((x - mean)/sd)^2)\n}\n\n# Define the central values for the input nodes\ncentral_values &lt;- c(1, 2, 3)\n\n# Define the input stimulus value\ninput_stimulus &lt;- 2\n\n# Generate a Gaussian curve image for each input node\nfor (i in seq_along(central_values)) {\n  # Define the mean and standard deviation for the Gaussian curve\n  mean &lt;- central_values[i]\n  sd &lt;- 1\n  # Generate the x values\n  x &lt;- seq(mean - 3*sd, mean + 3*sd, length.out = 100)\n  # Generate the y values\n  y &lt;- gaussian(x, mean, sd)\n  # Create the plot\n  p &lt;- ggplot(data.frame(x, y), aes(x, y)) +\n    geom_line() +\n    theme_minimal() +\n    labs(x = \"X\", y = \"Activation\", title = paste(\"Input Node\", i))\n  # Save the plot as a PNG image\n  ggsave(paste0(\"gaussian_curve_input_node_\", i, \".png\"), plot = p, width = 4, height = 3)\n}\n\n\n\n\n\n\n\nCode\ngrViz(\"digraph causal {\n                        # Nodes\n                        node [imagescale=true,shape = reactangle, fontname = Arial, style = filled]\n                        iv   [label = 'TRT', fillcolor = '#7FC97F']\n                        me   [label = 'Mediator', shape = ellipse]\n                        dv   [label = 'DLQI', fillcolor = '#7FC97F']\n                        \n                        # Edges\n                        edge [color = black, arrowhead = normal]\n                        rankdir = LR\n                        iv -&gt; me\n                        iv -&gt; dv [label = 'DIRECT', fontcolor = '#7FC97F', color = '#7FC97F']\n                        me -&gt; dv\n                        # Graph\n                        graph [overlap = true, fontsize = 10]\n                      }\")\n\n\n\n\n\n\nCode\ngrViz(\"digraph causal {\n                        # Nodes\n                        node [shape = reactangle, fontname = Arial, style = filled]\n                        iv   [image='gaussian_curve_input_node_1.png',label = '', fillcolor = '#7FC97F']\n                        me   [label = 'Mediator', shape = ellipse]\n                        dv   [label = 'DLQI', fillcolor = '#7FC97F']\n                        \n                        # Edges\n                        edge [color = black, arrowhead = normal]\n                        rankdir = LR\n                        iv -&gt; me\n                        iv -&gt; dv [label = 'DIRECT', fontcolor = '#7FC97F', color = '#7FC97F']\n                        me -&gt; dv\n                        # Graph\n                        graph [overlap = true, fontsize = 10]\n                      }\")\n\n\n\n\n\n\n\n\nCode\n# grViz('digraph structs {\n#     node [shape=plaintext];\n# \n#     struct1 [label=&lt;&lt;TABLE&gt;\n#       &lt;TR&gt;&lt;TD&gt;&lt;IMG SRC=\"gaussian_curve_input_node_1.png\"/&gt;&lt;/TD&gt;&lt;/TR&gt;\n#       &lt;TR&gt;&lt;TD&gt;caption&lt;/TD&gt;&lt;/TR&gt;\n#     &lt;/TABLE&gt;&gt;];\n# }')\n\n\nsvgDataUrl = \"data:image/svg+xml;base64,\"\ngrViz('\ndigraph {\n  node[imagescale=true, shape=circle, width=4, height=4,fontname=\"sans-serif\",penwidth=0]\n  a[label=&lt;&lt;FONT POINT-SIZE=\"10\"&gt;Transaction&lt;/FONT&gt;&lt;BR/&gt;&lt;FONT POINT-SIZE=\"36\"&gt;&lt;B&gt;TRNA&lt;/B&gt;&lt;/FONT&gt;&gt;,image=\"gaussian_curve_input_node_1.png\"]\n  b[label=&lt;&lt;FONT POINT-SIZE=\"10\"&gt;Transaction&lt;/FONT&gt;&lt;BR/&gt;&lt;FONT POINT-SIZE=\"18\"&gt;&lt;B&gt;TRNB&lt;/B&gt;&lt;/FONT&gt;&gt;,image=\"${svgDataUrl}\"]\n  c[label=&lt;&lt;FONT POINT-SIZE=\"10\"&gt;Transaction&lt;/FONT&gt;&lt;BR/&gt;&lt;FONT POINT-SIZE=\"24\"&gt;&lt;B&gt;TRNC&lt;/B&gt;&lt;/FONT&gt;&gt;,image=\"${svgDataUrl}\"]\n  a -&gt; b\n  a -&gt; c\n}')\n\n\n\n\n\n\nCode\ngrViz('digraph { a[image=\\\"gaussian_curve_input_node_1\\\"]; }\", {\n  images: [{ href: \"gaussian_curve_input_node_1.png\", width: \"400px\", height: \"300px\" }]\n}');\n\n\n\n\n\n\nCode\ngrViz('\ndigraph g{\n  node[imagescale=true, shape=circle, width=14, height=14,fontname=\"sans-serif\",penwidth=0]\n  I1[image=\"gaussian_curve_input_node_1.png\", label=\"\"];\n}')\n\n\n\n\n\n\nCode\ngrViz('digraph {\n    ratio=\"fill\";\n    size=\"10,10!\";\n    margin=\"0,0\";\n\n    node [shape=plain];\n    root [label=&lt;&lt;TABLE border=\"0\"&gt;&lt;TR&gt;&lt;TD&gt;&lt;IMG SRC=\"gaussian_curve_input_node_1\"/&gt;&lt;/TD&gt;&lt;/TR&gt;\n                                   &lt;TR&gt;&lt;TD&gt;text under&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&gt;];\n}')\n\n\n\n\n\n\n\n\n\nCode\ngrViz(\"\n  digraph ALM_EXAM {\n\n    # Graph attributes\n    graph [overlap = true, fontsize = 10, rankdir = LR]\n\n    # Node definitions\n    node [shape = box, fontname = Helvetica]\n    InputLayer [label = 'Input Layer']\n    OutputLayer [label = 'Output Layer']\n    ALM [label = 'ALM Response']\n    EXAM [label = 'EXAM Response']\n\n    node [shape = none, label = '']\n    I1 [image = 'gaussian_curve_input_node_1.png', label='']\n    I2 [image = 'gaussian_curve_input_node_2.png', label='']\n    I3 [image = 'gaussian_curve_input_node_3.png', label='']\n\n    node [shape = circle, fixedsize = true, width = 0.9]\n    O1 [label = 'Output Node 1']\n    O2 [label = 'Output Node 2']\n    O3 [label = 'Output Node 3']\n    O4 [label = 'Output Node 4']\n\n    # Edge definitions\n    InputLayer -&gt; I1\n    InputLayer -&gt; I2\n    InputLayer -&gt; I3\n    I1 -&gt; O1 [label = 'w1']\n    I1 -&gt; O2 [label = 'w2']\n    I1 -&gt; O3 [label = 'w3']\n    I1 -&gt; O4 [label = 'w4']\n    I2 -&gt; O1 [label = 'w5']\n    I2 -&gt; O2 [label = 'w6']\n    I2 -&gt; O3 [label = 'w7']\n    I2 -&gt; O4 [label = 'w8']\n    I3 -&gt; O1 [label = 'w9']\n    I3 -&gt; O2 [label = 'w10']\n    I3 -&gt; O3 [label = 'w11']\n    I3 -&gt; O4 [label = 'w12']\n    OutputLayer -&gt; O1\n    OutputLayer -&gt; O2\n    OutputLayer -&gt; O3\n    OutputLayer -&gt; O4\n    OutputLayer -&gt; ALM\n    OutputLayer -&gt; EXAM\n    ALM -&gt; EXAM [label = 'Pure ALM Model']\n    EXAM -&gt; ALM [label = 'ALM with EXAM Response Component']\n  }\n\")\n\n\n\n\n\n\n\n\nCode\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# define the global styles of the nodes. We can override these in box if we wish\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# edge definitions with the node IDs\n{data1 data2}  -&gt; process -&gt; statistical -&gt; results\n}\")\n\n\n\n\n\n\n\n\n\n\ngraph LR\n  subgraph InputLayer\n    I1[\"Input Node 1\"]\n    I2[\"Input Node 2\"]\n    I3[\"Input Node 3\"]\n  end\n  subgraph OutputLayer\n    O1[\"Output Node 1\"]\n    O2[\"Output Node 2\"]\n    O3[\"Output Node 3\"]\n    O4[\"Output Node 4\"]\n  end\n  I1 --&gt;|\"w1\"| O1\n  I1 --&gt;|\"w2\"| O2\n  I1 --&gt;|\"w3\"| O3\n  I1 --&gt;|\"w4\"| O4\n  I2 --&gt;|\"w5\"| O1\n  I2 --&gt;|\"w6\"| O2\n  I2 --&gt;|\"w7\"| O3\n  I2 --&gt;|\"w8\"| O4\n  I3 --&gt;|\"w9\"| O1\n  I3 --&gt;|\"w10\"| O2\n  I3 --&gt;|\"w11\"| O3\n  I3 --&gt;|\"w12\"| O4\n  style InputLayer fill:#99cc99,stroke:#333,stroke-width:2px\n  style OutputLayer fill:#cc99cc,stroke:#333,stroke-width:2px\n  IS[\"Input Stimulus (X)\"] --&gt; InputLayer\n  InputLayer --&gt;|\"Gaussian Activation (a_i)\"| OutputLayer\n  OutputLayer --&gt; ALM[\"ALM Response (m(X))\"]\n  OutputLayer --&gt; EXAM[\"EXAM Response (E[Y | X_i])\"]\n  ALM --&gt;|\"Pure ALM Model\"| EXAM\n  EXAM --&gt;|\"ALM with EXAM Response Component\"| ALM\n  linkStyle 0 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 1 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 2 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 3 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 4 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 5 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 6 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 7 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 8 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 9 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 10 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 11 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 12 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 13 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 14 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 15 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 16 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 17 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 0 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 1 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 2 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 3 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 4 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 5 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 6 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 7 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 8 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 9 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 10 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 11 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 12 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 13 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 14 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 15 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 16 stroke:#2ecd71,stroke-width:2px;\n  linkStyle 17 stroke:#2ecd71,stroke-width:2px;"
  },
  {
    "objectID": "Visuals_Interactives/model_viz.html#p5-sketching",
    "href": "Visuals_Interactives/model_viz.html#p5-sketching",
    "title": "Model Visualization",
    "section": "P5 sketching",
    "text": "P5 sketching\n\n\nCode\nP5 = require(\"p5\")\nfunction* createSketch(sketch) {\n  const element = DOM.element('div');\n  yield element;\n  const instance = new P5(sketch, element, true);\n  try {\n    while (true) {\n      yield element;\n    }\n  } finally {\n    instance.remove();\n  }\n}\ncreateSketch(s =&gt; {\n  \n    s.setup = function() {\n      s.createCanvas(746, 300);\n      s.textFont('Courgette');\n      s.textStyle(s.BOLD);\n      s.textAlign(s.CENTER, s.CENTER)\n\n      s.button = s.createButton('clear');\n      s.button.mousePressed(s.clearCanvas);\n        s.text('Click and drag to draw', s.width/2, s.height/10);\n\n    };\n    s.draw = function() {\n    if (s.mouseIsPressed) {\n    s.fill(0);\n    s.ellipse(s.mouseX, s.mouseY, 10, 10);\n    } else {\n   //s.fill(255);\n    }\n  // add text input\n\n    };\n\n  // add button to clear canvas\n  s.clearCanvas = function() {\n    s.clear();\n  };\n  // add text\n  // add slider\n  }\n)"
  },
  {
    "objectID": "Visuals_Interactives/mermaid_consort.html",
    "href": "Visuals_Interactives/mermaid_consort.html",
    "title": "Mermaid with R + consort",
    "section": "",
    "text": "Code\n#lapply(c('tidyverse','data.table','igraph','ggraph','kableExtra'),library,character.only=TRUE))\npacman::p_load(tidyverse,data.table,igraph,ggraph,kableExtra,DiagrammeR,png,consort,data.table) \n\n\n\n\n\n\n\n\n\nALM\n\n  \n\nInput1\n\n Input1   \n\nInput2\n\n Input2    \n\nOutput1\n\n Output1   \n\nInput1-&gt;Output1\n\n  w_{11}   \n\nOutput2\n\n Output2   \n\nInput1-&gt;Output2\n\n  w_{12}   \n\nOutput3\n\n Output3   \n\nInput1-&gt;Output3\n\n  w_{13}   \n\nInput2-&gt;Output1\n\n  w_{21}   \n\nInput2-&gt;Output2\n\n  w_{22}   \n\nInput2-&gt;Output3\n\n  w_{23}   \n\nequation1\n\na_i(X) = e{-γ(X-X_i)2}, normalized: a_i(X) / Σa_i(X)      \n\nequation2\n\nO_j(X) = Σ w_{ji} ⋅ a_i(X), P[Y_j | X] = O_j(X) / Σ O_k(X)       \n\n\n\n\n\n\n\n\n\n\n\n\nALM\n\n \n\ncluster_output\n\n Output Layer  \n\ncluster_input\n\n Input Layer   \n\nInput1\n\n Input1   \n\nOutput1\n\n Output1   \n\nInput1-&gt;Output1\n\n  w_11   \n\nOutput2\n\n Output2   \n\nInput1-&gt;Output2\n\n  w_12   \n\nOutput3\n\n Output3   \n\nInput1-&gt;Output3\n\n  w_13   \n\nInput2\n\n Input2   \n\nInput2-&gt;Output1\n\n  w_21   \n\nInput2-&gt;Output2\n\n  w_22   \n\nInput2-&gt;Output3\n\n  w_23   \n\nequation1\n\nInput activation ai(X) = exp(-gamma*(X-Xi)^2), normalized by dividing by sum     \n\nequation2\n\nOutput Oj(X) = sum(w_ji * ai(X)), Probability P[Yj | X] = Oj(X) / sum(Ok(X))    \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nE1\n\n⋮   \n\nz\n\n z    \n\nE2\n\n⋮   \n\nx100\n\n x100    \n\na\n\n a   \n\nb\n\n b    \n\nx1\n\n x1   \n\na-&gt;x1\n\n    \n\nx2\n\n x2   \n\na-&gt;x2\n\n    \n\na-&gt;x100\n\n     \n\nb-&gt;x1\n\n    \n\nb-&gt;x2\n\n    \n\nb-&gt;x100\n\n    \n\nz-&gt;x1\n\n    \n\nz-&gt;x2\n\n    \n\nz-&gt;x100\n\n     \n\nY\n\n Y   \n\nx1-&gt;Y\n\n     \n\nx2-&gt;Y\n\n    \n\nx100-&gt;Y\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n \n\nclusterX\n\n   \n\nn1\n\n  \n\nn2\n\n  \n\nn1-&gt;n2\n\n    \n\nn3\n\n  \n\nn1-&gt;n3\n\n    \n\nn4\n\n   \n\nn2-&gt;n4\n\n    \n\nn5\n\n   \n\nn4-&gt;n5\n\n    \n\nn6\n\n   \n\nn5-&gt;n6\n\n    \n\nJ1\n\n  \n\nJ2\n\n   \n\nJ1-&gt;J2\n\n    \n\nJ6\n\n   \n\nJ1-&gt;J6\n\n    \n\nJ4\n\n  \n\nJ5\n\n   \n\nJ5-&gt;J4\n\n    \n\nJ6-&gt;J5\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nE1\n\n E1   \n\nz\n\n z    \n\nE2\n\n⋮   \n\nx100\n\n x100    \n\na\n\n a   \n\nb\n\n b    \n\nx1\n\n x1   \n\na-&gt;x1\n\n    \n\nx2\n\n x2   \n\na-&gt;x2\n\n    \n\na-&gt;x100\n\n     \n\nb-&gt;x1\n\n    \n\nb-&gt;x2\n\n    \n\nb-&gt;x100\n\n    \n\nz-&gt;x1\n\n    \n\nz-&gt;x2\n\n    \n\nz-&gt;x100\n\n     \n\nY\n\n Y   \n\nx1-&gt;Y\n\n     \n\nx2-&gt;Y\n\n    \n\nx100-&gt;Y\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nn1\n\n  \n\nn2\n\n  \n\nn1-&gt;n2\n\n    \n\nn4\n\n  \n\nn2-&gt;n4\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\nALM\n\n  \n\nInput1\n\n X 1   \n\nInput2\n\n X 2    \n\nOutput1\n\n Y 1   \n\nInput1:e-&gt;Output1:w\n\n  w 11   \n\nOutput2\n\n Y 2   \n\nInput1:e-&gt;Output2:w\n\n  w 12   \n\nOutput3\n\n Y 3   \n\nInput1:e-&gt;Output3:w\n\n  w 13   \n\nInput2:e-&gt;Output1:w\n\n  w 21   \n\nInput2:e-&gt;Output2:w\n\n  w 22   \n\nInput2:e-&gt;Output3:w\n\n  w 23     \n\nlabel_input\n\nInput Layer    \n\nlabel_output\n\nOutput Layer   \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n \n\ncluster_0\n\n layer 1 (input layer)  \n\ncluster_1\n\n layer 2 (hidden layer)  \n\ncluster_2\n\n layer 3 (hidden layer)  \n\ncluster_3\n\n layer 4 (output layer)   \n\nx0\n\n x 0   \n\na02\n\n a 0 (2)   \n\nx0:e-&gt;a02:w\n\n  \n\na12\n\n a 5 (2)   \n\nx0:e-&gt;a12:w\n\n    \n\na22\n\n a 1 (2)   \n\nx0:e-&gt;a22:w\n\n    \n\na32\n\n a 2 (2)   \n\nx0:e-&gt;a32:w\n\n    \n\na42\n\n a 3 (2)   \n\nx0:e-&gt;a42:w\n\n    \n\na52\n\n a 4 (2)   \n\nx0:e-&gt;a52:w\n\n    \n\nx1\n\n x 1   \n\nx1:e-&gt;a12:w\n\n    \n\nx1:e-&gt;a22:w\n\n    \n\nx1:e-&gt;a32:w\n\n    \n\nx1:e-&gt;a42:w\n\n    \n\nx1:e-&gt;a52:w\n\n    \n\nx2\n\n x 2   \n\nx2:e-&gt;a12:w\n\n    \n\nx2:e-&gt;a22:w\n\n    \n\nx2:e-&gt;a32:w\n\n    \n\nx2:e-&gt;a42:w\n\n    \n\nx2:e-&gt;a52:w\n\n    \n\nx3\n\n x 3   \n\nx3:e-&gt;a12:w\n\n    \n\nx3:e-&gt;a22:w\n\n    \n\nx3:e-&gt;a32:w\n\n    \n\nx3:e-&gt;a42:w\n\n    \n\nx3:e-&gt;a52:w\n\n    \n\na03\n\n a 0 (3)   \n\na02:e-&gt;a03:w\n\n  \n\na13\n\n a 3 (3)   \n\na02:e-&gt;a13:w\n\n    \n\na23\n\n a 4 (3)   \n\na02:e-&gt;a23:w\n\n    \n\na33\n\n a 5 (3)   \n\na02:e-&gt;a33:w\n\n    \n\na43\n\n a 1 (3)   \n\na02:e-&gt;a43:w\n\n    \n\na53\n\n a 2 (3)   \n\na02:e-&gt;a53:w\n\n    \n\na12:e-&gt;a13:w\n\n    \n\na12:e-&gt;a23:w\n\n    \n\na12:e-&gt;a33:w\n\n    \n\na12:e-&gt;a43:w\n\n    \n\na12:e-&gt;a53:w\n\n    \n\na22:e-&gt;a13:w\n\n    \n\na22:e-&gt;a23:w\n\n    \n\na22:e-&gt;a33:w\n\n    \n\na22:e-&gt;a43:w\n\n    \n\na22:e-&gt;a53:w\n\n    \n\na32:e-&gt;a13:w\n\n    \n\na32:e-&gt;a23:w\n\n    \n\na32:e-&gt;a33:w\n\n    \n\na32:e-&gt;a43:w\n\n    \n\na32:e-&gt;a53:w\n\n    \n\na42:e-&gt;a13:w\n\n    \n\na42:e-&gt;a23:w\n\n    \n\na42:e-&gt;a33:w\n\n    \n\na42:e-&gt;a43:w\n\n    \n\na42:e-&gt;a53:w\n\n    \n\na52:e-&gt;a13:w\n\n    \n\na52:e-&gt;a23:w\n\n    \n\na52:e-&gt;a33:w\n\n    \n\na52:e-&gt;a43:w\n\n    \n\na52:e-&gt;a53:w\n\n    \n\nO1\n\n a 1 (4)   \n\na03:e-&gt;O1:w\n\n    \n\nO2\n\n a 2 (4)   \n\na03:e-&gt;O2:w\n\n    \n\nO3\n\n a 3 (4)   \n\na03:e-&gt;O3:w\n\n    \n\nO4\n\n a 4 (4)   \n\na03:e-&gt;O4:w\n\n    \n\na13:e-&gt;O1:w\n\n    \n\na13:e-&gt;O2:w\n\n    \n\na13:e-&gt;O3:w\n\n    \n\na13:e-&gt;O4:w\n\n    \n\na23:e-&gt;O1:w\n\n    \n\na23:e-&gt;O2:w\n\n    \n\na23:e-&gt;O3:w\n\n    \n\na23:e-&gt;O4:w\n\n    \n\na33:e-&gt;O1:w\n\n    \n\na33:e-&gt;O2:w\n\n    \n\na33:e-&gt;O3:w\n\n    \n\na33:e-&gt;O4:w\n\n    \n\na43:e-&gt;O1:w\n\n    \n\na43:e-&gt;O2:w\n\n    \n\na43:e-&gt;O3:w\n\n    \n\na43:e-&gt;O4:w\n\n    \n\na53:e-&gt;O1:w\n\n    \n\na53:e-&gt;O2:w\n\n    \n\na53:e-&gt;O3:w\n\n    \n\na53:e-&gt;O4:w\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n \n\ncluster_0\n\n layer 1 (Input layer)  \n\ncluster_1\n\n layer 2 (hidden layer)  \n\ncluster_2\n\n layer 3 (output layer)   \n\nx1\n\n   \n\na12\n\n   \n\nx1-&gt;a12\n\n    \n\na22\n\n   \n\nx1-&gt;a22\n\n    \n\na32\n\n   \n\nx1-&gt;a32\n\n    \n\nx2\n\n   \n\nx2-&gt;a12\n\n    \n\nx2-&gt;a22\n\n    \n\nx2-&gt;a32\n\n    \n\nx3\n\n   \n\nx3-&gt;a12\n\n    \n\nx3-&gt;a22\n\n    \n\nx3-&gt;a32\n\n    \n\nO\n\n   \n\na12-&gt;O\n\n    \n\na22-&gt;O\n\n    \n\na32-&gt;O\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\nG\n\n  \n\nx0\n\n x 0   \n\nx1\n\n x 1    \n\na12\n\n a 1 (2)   \n\nx0:e-&gt;a12:w\n\n    \n\na22\n\n a 2 (2)   \n\nx0:e-&gt;a22:w\n\n    \n\na32\n\n a 3 (2)   \n\nx0:e-&gt;a32:w\n\n    \n\na42\n\n a 4 (2)   \n\nx0:e-&gt;a42:w\n\n    \n\na52\n\n a 5 (2)   \n\nx0:e-&gt;a52:w\n\n    \n\na02\n\n a 0 (2)   \n\na03\n\n a 0 (3)     \n\na13\n\n a 1 (3)   \n\na02:e-&gt;a13:w\n\n    \n\na23\n\n a 2 (3)   \n\na02:e-&gt;a23:w\n\n    \n\na33\n\n a 3 (3)   \n\na02:e-&gt;a33:w\n\n    \n\na43\n\n a 4 (3)   \n\na02:e-&gt;a43:w\n\n    \n\na53\n\n a 5 (3)   \n\na02:e-&gt;a53:w\n\n     \n\nO1\n\n a 1 (4)   \n\na03:e-&gt;O1:w\n\n    \n\nO2\n\n a 2 (4)   \n\na03:e-&gt;O2:w\n\n    \n\nO3\n\n a 3 (4)   \n\na03:e-&gt;O3:w\n\n    \n\nO4\n\n a 4 (4)   \n\na03:e-&gt;O4:w\n\n    \n\nx2\n\n x 2    \n\nx1:e-&gt;a12:w\n\n    \n\nx1:e-&gt;a22:w\n\n    \n\nx1:e-&gt;a32:w\n\n    \n\nx1:e-&gt;a42:w\n\n    \n\nx1:e-&gt;a52:w\n\n    \n\nx3\n\n x 3    \n\nx2:e-&gt;a12:w\n\n    \n\nx2:e-&gt;a22:w\n\n    \n\nx2:e-&gt;a32:w\n\n    \n\nx2:e-&gt;a42:w\n\n    \n\nx2:e-&gt;a52:w\n\n    \n\nx3:e-&gt;a12:w\n\n    \n\nx3:e-&gt;a22:w\n\n    \n\nx3:e-&gt;a32:w\n\n    \n\nx3:e-&gt;a42:w\n\n    \n\nx3:e-&gt;a52:w\n\n     \n\na12:e-&gt;a13:w\n\n    \n\na12:e-&gt;a23:w\n\n    \n\na12:e-&gt;a33:w\n\n    \n\na12:e-&gt;a43:w\n\n    \n\na12:e-&gt;a53:w\n\n     \n\na22:e-&gt;a13:w\n\n    \n\na22:e-&gt;a23:w\n\n    \n\na22:e-&gt;a33:w\n\n    \n\na22:e-&gt;a43:w\n\n    \n\na22:e-&gt;a53:w\n\n     \n\na32:e-&gt;a13:w\n\n    \n\na32:e-&gt;a23:w\n\n    \n\na32:e-&gt;a33:w\n\n    \n\na32:e-&gt;a43:w\n\n    \n\na32:e-&gt;a53:w\n\n     \n\na42:e-&gt;a13:w\n\n    \n\na42:e-&gt;a23:w\n\n    \n\na42:e-&gt;a33:w\n\n    \n\na42:e-&gt;a43:w\n\n    \n\na42:e-&gt;a53:w\n\n    \n\na52:e-&gt;a13:w\n\n    \n\na52:e-&gt;a23:w\n\n    \n\na52:e-&gt;a33:w\n\n    \n\na52:e-&gt;a43:w\n\n    \n\na52:e-&gt;a53:w\n\n     \n\na13:e-&gt;O1:w\n\n    \n\na13:e-&gt;O2:w\n\n    \n\na13:e-&gt;O3:w\n\n    \n\na13:e-&gt;O4:w\n\n     \n\na23:e-&gt;O1:w\n\n    \n\na23:e-&gt;O2:w\n\n    \n\na23:e-&gt;O3:w\n\n    \n\na23:e-&gt;O4:w\n\n     \n\na33:e-&gt;O1:w\n\n    \n\na33:e-&gt;O2:w\n\n    \n\na33:e-&gt;O3:w\n\n    \n\na33:e-&gt;O4:w\n\n     \n\na43:e-&gt;O1:w\n\n    \n\na43:e-&gt;O2:w\n\n    \n\na43:e-&gt;O3:w\n\n    \n\na43:e-&gt;O4:w\n\n    \n\na53:e-&gt;O1:w\n\n    \n\na53:e-&gt;O2:w\n\n    \n\na53:e-&gt;O3:w\n\n    \n\na53:e-&gt;O4:w\n\n       \n\nl0\n\nlayer 1 (input layer)    \n\nl1\n\nlayer 2 (hidden layer)    \n\nl2\n\nlayer 3 (hidden layer)    \n\nl3\n\nlayer 4 (output layer)   \n\n\n\n\n\n\n\n\n\n\n\n\nthreevar\n\n  \n\nk\n\n ?   \n\nX1\n\n X1   \n\nk-&gt;X1\n\n  n@_{S}   \n\nX2\n\n X2   \n\nk-&gt;X2\n\n  θ@^{(h)}   \n\nX3\n\n X3   \n\nk-&gt;X3\n\n  ?3   \n\nz1\n\n d1   \n\nz1-&gt;X1\n\n    \n\nz2\n\n d2   \n\nz2-&gt;X2\n\n    \n\nz3\n\n d3   \n\nz3-&gt;X3\n\n   \n\n\n\n\n\n\n\nCode\ngrViz('digraph threevar {\n      rankdir=LR;\n      size=\"8,4\";\n      node [fontsize=14 shape=box];\n      edge [fontsize=10];\n      center=1;\n      {rank=min k }\n      {rank=same X1 X2 X3 }\n      {rank=max z1 z2 z3 }\n      z1 [shape=circle label=\"d1\"];\n      z2 [shape=circle label=\"d2\"];\n      z3 [shape=circle label=\"d3\"];\n      k [label=\"?\" shape=\"ellipse\"];\n      k -&gt; X1 [label=\"n@_{S}\"];\n      k -&gt; X2 [label=\"&theta;@^{(h)}\"];\n      k -&gt; X3 [label=\"?3\"];\n      z1 -&gt; X1;\n      z2 -&gt; X2;\n      z3 -&gt; X3;\n    }\n      ')\n\n\n\n\n\n\n\n\nCode\ngrViz(\"digraph dot {\n      graph [style = filled, fillcolor = white]\n      \n      node [shape = circle,\n            style = filled, fillcolor = white,\n            fixedsize = true, width = 0.5, height = 0.5,\n            fontname = 'Times-italic']\n        c\n        d\n      node [shape = doublecircle,\n            style = filled, fillcolor = white,\n            fixedsize = true, width = 0.5, height = 0.5,\n            fontname = 'Times-italic']\n        thetah [label = '&theta;@^{(h)}']\n        thetaf [label = '&theta;@^{(f)}']\n      node [shape = square,\n            style = filled, fillcolor = grey,\n            fixedsize = true, width=0.5, height=0.5,\n            fontname = 'Times-italic']\n        h\n        f\n        ns [label = 'n@_{S}']\n        nn [label = 'n@_{N}']\n      \n      edge [color = black]\n        c -&gt; thetah -&gt; h\n        d -&gt; thetaf -&gt; f\n        c -&gt; thetaf\n        d -&gt; thetah\n        ns -&gt; h\n        nn -&gt; f\n      {rank = max; ns; nn}\n      }\")\n\n\n\n\n\n\nCode\ngrViz(\"digraph dot {\n      graph [style = filled, fillcolor = white,\n             rankdir = LR,\n             newrank = true]\n      \n      node [shape = circle,\n            style = filled, fillcolor = white,\n            fixedsize = true, width = 0.5, height = 0.5,\n            fontname = 'Times-italic']\n        p [fillcolor = gray]\n        gamma [label = '&gamma;']\n        omega [label = '&omega;', shape = doublecircle]\n        beta [label = '&beta;']\n      subgraph cluster_out{\n        fontsize = 8\n        label = &lt;&lt;I&gt;j&lt;/I&gt;:試行&gt;\n        labelloc = b\n        labeljust = r\n        subgraph cluster_in{\n          fontsize = 8\n          label = &lt;&lt;I&gt;k&lt;/I&gt;:回数&gt;\n          labelloc = b\n          labeljust = r\n          thetajk [label = '&theta;@_{jk}', shape = doublecircle]\n          djk [label = 'd@_{jk}', shape = square, fillcolor = gray]\n        }}\n      edge [color=black]\n        p -&gt; omega -&gt; thetajk -&gt; djk\n        gamma -&gt; omega\n        beta -&gt; thetajk \n      {rank = same; gamma; omega}\n      {rank = same; beta; thetajk}\n      }\")\n\n\n\n\n\n\nCode\ngrViz('\ndigraph G {\n    fontname=\"Helvetica,Arial,sans-serif\"\n    node [fontname=\"Helvetica,Arial,sans-serif\"]\n    edge [fontname=\"Helvetica,Arial,sans-serif\"]\n\n    subgraph cluster_0 {\n        style=filled;\n        color=lightgrey;\n        node [style=filled,color=white];\n        a0 -&gt; a1 -&gt; a2 -&gt; a3;\n        label = \"process #1\";\n    }\n\n    subgraph cluster_1 {\n        node [style=filled];\n        b0 -&gt; b1 -&gt; b2 -&gt; b3;\n        label = \"process #2\";\n        color=blue\n    }\n    start -&gt; a0;\n    start -&gt; b0;\n    a1 -&gt; b3;\n    b2 -&gt; a3;\n    a3 -&gt; a0;\n    a3 -&gt; end;\n    b3 -&gt; end;\n\n    start [shape=Mdiamond];\n    end [shape=Msquare];\n}')\n\n\n\n\n\n\nCode\n#https://graphviz.org/Gallery/directed/neural-network.html\n\ngrViz('digraph G {\n  fontname=\"Helvetica,Arial,sans-serif\"\n  node [fontname=\"Helvetica,Arial,sans-serif\"]\n  edge [fontname=\"Helvetica,Arial,sans-serif\"]\n  concentrate=True;\n  rankdir=TB;\n  node [shape=record];\n  140087530674552 [label=\"title: InputLayer\\n|{input:|output:}|{{[(?, ?)]}|{[(?, ?)]}}\"];\n  140087537895856 [label=\"body: InputLayer\\n|{input:|output:}|{{[(?, ?)]}|{[(?, ?)]}}\"];\n  140087531105640 [label=\"embedding_2: Embedding\\n|{input:|output:}|{{(?, ?)}|{(?, ?, 64)}}\"];\n  140087530711024 [label=\"embedding_3: Embedding\\n|{input:|output:}|{{(?, ?)}|{(?, ?, 64)}}\"];\n  140087537980360 [label=\"lstm_2: LSTM\\n|{input:|output:}|{{(?, ?, 64)}|{(?, 128)}}\"];\n  140087531256464 [label=\"lstm_3: LSTM\\n|{input:|output:}|{{(?, ?, 64)}|{(?, 32)}}\"];\n  140087531106200 [label=\"tags: InputLayer\\n|{input:|output:}|{{[(?, 12)]}|{[(?, 12)]}}\"];\n  140087530348048 [label=\"concatenate_1: Concatenate\\n|{input:|output:}|{{[(?, 128), (?, 32), (?, 12)]}|{(?, 172)}}\"];\n  140087530347992 [label=\"priority: Dense\\n|{input:|output:}|{{(?, 172)}|{(?, 1)}}\"];\n  140087530711304 [label=\"department: Dense\\n|{input:|output:}|{{(?, 172)}|{(?, 4)}}\"];\n  140087530674552 -&gt; 140087531105640;\n  140087537895856 -&gt; 140087530711024;\n  140087531105640 -&gt; 140087537980360;\n  140087530711024 -&gt; 140087531256464;\n  140087537980360 -&gt; 140087530348048;\n  140087531256464 -&gt; 140087530348048;\n  140087531106200 -&gt; 140087530348048;\n  140087530348048 -&gt; 140087530347992;\n  140087530348048 -&gt; 140087530711304;\n}')\n\n\n\n\n\n\n\n\nCode\nrequire(data.table)\nrequire(qreport)\nrequire(consort)\n\n# Load the necessary libraries\nrequire(data.table)\nrequire(qreport)\n\n# Define the mermaid diagram\nx &lt;- '\ngraph LR\n  InputLayer[Input Layer] --&gt; I1[{{I1}}]\n  InputLayer --&gt; I2[{{I2}}]\n  InputLayer --&gt; I3[{{I3}}]\n  I1 --&gt; O1[w1]\n  I1 --&gt; O2[w2]\n  I1 --&gt; O3[w3]\n  I1 --&gt; O4[w4]\n  I2 --&gt; O1[w5]\n  I2 --&gt; O2[w6]\n  I2 --&gt; O3[w7]\n  I2 --&gt; O4[w8]\n  I3 --&gt; O1[w9]\n  I3 --&gt; O2[w10]\n  I3 --&gt; O3[w11]\n  I3 --&gt; O4[w12]\n  OutputLayer[Output Layer] --&gt; O1\n  OutputLayer --&gt; O2\n  OutputLayer --&gt; O3\n  OutputLayer --&gt; O4\n  OutputLayer --&gt; ALM[ALM Response]\n  OutputLayer --&gt; EXAM[EXAM Response]\n  ALM --&gt; EXAM[Pure ALM Model]\n  EXAM --&gt; ALM[ALM with EXAM Response Component]\n'\n\n# Generate the mermaid diagram\nmakemermaid(x,\n            I1 = '![Gaussian Curve](gaussian_curve_input_node_1.png)',\n            I2 = '![Gaussian Curve](gaussian_curve_input_node_2.png)',\n            I3 = '![Gaussian Curve](gaussian_curve_input_node_3.png)',\n            file = 'alm_exam.mer'\n            )\n\n# Output the mermaid diagram\n# cat('```{mermaid}\\n')\n# cat(readLines('alm_exam.mer'), sep = '\\n')\n# cat('```\\n')\n\n\n\n\n\n\n\ngraph LR\n  InputLayer[Input Layer] --&gt; I1[![Gaussian Curve](gaussian_curve_input_node_1.png)]\n  InputLayer --&gt; I2[![Gaussian Curve](gaussian_curve_input_node_2.png)]\n  InputLayer --&gt; I3[![Gaussian Curve](gaussian_curve_input_node_3.png)]\n  I1 --&gt; O1[w1]\n  I1 --&gt; O2[w2]\n  I1 --&gt; O3[w3]\n  I1 --&gt; O4[w4]\n  I2 --&gt; O1[w5]\n  I2 --&gt; O2[w6]\n  I2 --&gt; O3[w7]\n  I2 --&gt; O4[w8]\n  I3 --&gt; O1[w9]\n  I3 --&gt; O2[w10]\n  I3 --&gt; O3[w11]\n  I3 --&gt; O4[w12]\n  OutputLayer[Output Layer] --&gt; O1\n  OutputLayer --&gt; O2\n  OutputLayer --&gt; O3\n  OutputLayer --&gt; O4\n  OutputLayer --&gt; ALM[ALM Response]\n  OutputLayer --&gt; EXAM[EXAM Response]\n  ALM --&gt; EXAM[Pure ALM Model]\n  EXAM --&gt; ALM[ALM with EXAM Response Component]\n\n\nFigure 1: ALM diagram produced with mermaid with individual exclusions linked to the overall exclusions node, and with a tooltip to show more detail\n\n\n\n\n\n\nCode\nlibrary(consort)\nset.seed(1001)\nN &lt;- 300\n\ntrialno &lt;- sample(c(1000:2000), N)\nexc &lt;- rep(NA, N)\nexc[sample(1:N, 15)] &lt;- sample(c(\"Sample not collected\", \"MRI not collected\", \"Other\"),\n                                15, replace = T, prob = c(0.4, 0.4, 0.2))\n\narm &lt;- rep(NA, N)\narm[is.na(exc)] &lt;- sample(c(\"Conc\", \"Seq\"), sum(is.na(exc)), replace = T)\n\nfow1 &lt;- rep(NA, N)\nfow1[!is.na(arm)] &lt;- sample(c(\"Withdraw\", \"Discontinued\", \"Death\", \"Other\", NA),\n                            sum(!is.na(arm)), replace = T, \n                            prob = c(0.05, 0.05, 0.05, 0.05, 0.8))\nfow2 &lt;- rep(NA, N)\nfow2[!is.na(arm) & is.na(fow1)] &lt;- sample(c(\"Protocol deviation\", \"Outcome missing\", NA),\n                                          sum(!is.na(arm) & is.na(fow1)), replace = T, \n                                          prob = c(0.05, 0.05, 0.9))\ndf &lt;- data.frame(trialno, exc, arm, fow1, fow2)\nout &lt;- consort_plot(data = df,\n             order = c(trialno = \"Population\",\n                          exc    = \"Excluded\",\n                          arm     = \"Randomized patient\",\n                          fow1    = \"Lost of Follow-up\",\n                          trialno = \"Finished Followup\",\n                          fow2    = \"Not evaluable\",\n                          trialno = \"Final Analysis\"),\n             side_box = c(\"exc\", \"fow1\", \"fow2\"),\n             allocation = \"arm\",\n             labels = c(\"1\" = \"Screening\", \"2\" = \"Randomization\",\n                        \"5\" = \"Final\"),\n             cex = 0.6)\n\nplot(out)\n\n\n\n\n\n\n\nCode\nplot(out, grViz = TRUE)\n\n\n\n\n\n\n\n\nCode\nrequire(Hmisc)\nrequire(data.table)\nrequire(qreport)\nhookaddcap()\nN &lt;- 1000\nset.seed(1)\nr &lt;- data.table(\n  id    = 1 : N,\n  age   = round(rnorm(N, 60, 15)),\n  pain  = sample(0 : 5, N, replace=TRUE),\n  hxmed = sample(0 : 1, N, replace=TRUE, prob=c(0.95, 0.05))   )\n# Set consent status to those not excluded at screening\nr[age &gt;= 40 & pain &gt; 0 & hxmed == 0,\n  consent := sample(0 : 1, .N, replace=TRUE, prob=c(0.1, 0.9))]\n# Set randomization status for those consenting\nr[consent == 1,\n  randomized := sample(0 : 1, .N, replace=TRUE, prob=c(0.15, 0.85))]\n# Add treatment and follow-up time to randomized subjects\nr[randomized == 1, tx     := sample(c('A', 'B'), .N, replace=TRUE)]\nr[randomized == 1, futime := pmin(runif(.N, 0, 10), 3)]\n# Add outcome status for those followed 3 years\n# Make a few of those followed 3 years missing\nr[futime == 3,\n  y := sample(c(0, 1, NA), .N, replace=TRUE, prob=c(0.75, 0.2, 0.05))]\n# Print first 15 subjects\nkabl(r[1 : 15, ])\n\n\n\n\n\nid\nage\npain\nhxmed\nconsent\nrandomized\ntx\nfutime\ny\n\n\n\n\n1\n51\n2\n1\nNA\nNA\nNA\nNA\nNA\n\n\n2\n63\n2\n0\n1\n1\nA\n3.0000\n0\n\n\n3\n47\n1\n0\n1\n1\nA\n3.0000\nNA\n\n\n4\n84\n5\n0\n1\n0\nNA\nNA\nNA\n\n\n5\n65\n3\n0\n1\n1\nB\n3.0000\n1\n\n\n6\n48\n4\n0\n1\n1\nA\n3.0000\n0\n\n\n7\n67\n3\n0\n1\n1\nB\n2.0566\nNA\n\n\n8\n71\n0\n0\nNA\nNA\nNA\nNA\nNA\n\n\n9\n69\n5\n0\n1\n1\nB\n1.2815\nNA\n\n\n10\n55\n2\n0\n1\n1\nB\n1.2388\nNA\n\n\n11\n83\n4\n0\n1\n1\nA\n3.0000\n1\n\n\n12\n66\n5\n0\n1\n1\nA\n3.0000\n0\n\n\n13\n51\n1\n0\n1\n1\nB\n3.0000\n0\n\n\n14\n27\n2\n0\nNA\nNA\nNA\nNA\nNA\n\n\n15\n77\n2\n0\n1\n1\nA\n3.0000\n0\n\n\n\n\n\n\n\nCode\nr[, exc := seqFreq('pain-free'  = pain  == 0,\n                    'Hx med'    = hxmed == 1,\n                                  age &lt; 40,\n                    noneNA=TRUE)]\neo  &lt;- attr(r[, exc], 'obs.per.numcond')\nmult &lt;- paste0('1, 2, ≥3 exclusions: n=',\n                eo[2], ', ',\n                eo[3], ', ',\n                eo[-(1:3)]  )\n\nr[, .q(qual, consent, fin) :=\n    .(is.na(exc),\n      ifelse(consent == 1, 1, NA),\n      ifelse(futime  &gt;= 3, 1, NA))]\n            \nrequire(consort)\n# consort_plot used to take a coords=c(0.4, 0.6) argument that prevented\n# the collision you see here\nconsort_plot(r,\n             orders = c(id      = 'Screened',\n                        exc     = 'Excluded',\n                        qual    = 'Qualified for Randomization',\n                        consent = 'Consented',\n                        tx      = 'Randomized',\n                        fin     = 'Finished',\n                        y       = 'Outcome\\nassessed'),\n             side_box = 'exc',\n             allocation = 'tx',\n             labels=c('1'='Screening', '3'='Consent', '4'='Randomization', '6'='Follow-up'))\n\n\n\n\n\n\n\nCode\nh &lt;- function(n, label) paste0(label, ' (n=', n, ')')\nhtab &lt;- function(x, label=NULL, split=! length(label), br='\\n') {\n  tab &lt;- table(x)\n  w &lt;- if(length(label)) paste0(h(sum(tab), label), ':', br)\n  f &lt;- if(split) h(tab, names(tab)) \n  else\n    paste(paste0('   ', h(tab, names(tab))), collapse=br)\n  if(split) return(f)\n  paste(w, f, sep=if(length(label))'' else br)\n}  \ncount &lt;- function(x, by=rep(1, length(x)))\n  tapply(x, by, sum, na.rm=TRUE)\n\nw &lt;- r[, {\n g &lt;-\n   add_box(txt=h(nrow(r),       'Screened'))                    |&gt;\n   add_side_box(htab(exc,       'Excluded'))                    |&gt;\n   add_box(h(count(is.na(exc)), 'Qualified for Randomization')) |&gt;\n   add_box(h(count(consent),    'Consented'))                   |&gt;\n   add_box(h(count(randomized), 'Randomized'))                  |&gt;\n   add_split(htab(tx))                                          |&gt;\n   add_box(h(count(fin, tx),    'Finished'))                    |&gt;\n   add_box(h(count(! is.na(y), tx), 'Outcome\\nassessed'))       |&gt;\n   add_label_box(c('1'='Screening',     '3'='Consent',\n                   '4'='Randomization', '6'='Follow-up'))\n plot(g)\n}\n]\n\n\n\n\n\n\n\nCode\naddCap('fig-doverview-mermaid1', 'Consort diagram produced by `mermaid`')\nx &lt;- 'flowchart TD\n  S[\"Screened (n={{N0}})\"] --&gt; E[\"{{excl}}\"]\n  S   --&gt; Q[\"Qualified for Randomization (n={{Nq}})\"]\n  Q   --&gt; C[\"Consented (n={{Nc}})\"]\n  C   --&gt; R[\"Randomized (n={{Nr}})\"]\n  R   --&gt; TxA[\"A (n={{Ntxa}})\"]\n  R   --&gt; TxB[\"B (n={{Ntxb}})\"]\n  TxA --&gt; FA[\"Finished (n={{Ntxaf}})\"]\n  TxB --&gt; FB[\"Finished (n={{Ntxbf}})\"]\n  FA  --&gt; OA[\"Outcome assessed (n={{Ntxao}})\"]\n  FB  --&gt; OB[\"Outcome assessed (n={{Ntxbo}})\"]\nclassDef largert fill:lightgray,width:1.5in,height:10em,text-align:right,font-size:0.8em;\nclass E largert;\n'\n\nw &lt;- r[, \nmakemermaid(x,\n            N0   = nrow(r),\n            excl = htab(exc, 'Excluded', br='&lt;br&gt;'),\n            Nq   = count(is.na(exc)),\n            Nc   = count(consent),\n            Nr   = count(randomized),\n            Ntxa = count(tx == 'A'),\n            Ntxb = count(tx == 'B'),\n            Ntxaf= count(tx == 'A' & fin),\n            Ntxbf= count(tx == 'B' & fin),\n            Ntxao= count(tx == 'A' & ! is.na(y)),\n            Ntxbo= count(tx == 'B' & ! is.na(y)),\n            file = 'mermaid1.mer'\n            )\n]\n\n\n\n\n\n\n\nflowchart TD\n  S[\"Screened (n=1000)\"] --&gt; E[\"Excluded (n=286):&lt;br&gt;   pain-free (n=156)&lt;br&gt;   age &lt; 40 (n=85)&lt;br&gt;   Hx med (n=45)\"]\n  S   --&gt; Q[\"Qualified for Randomization (n=714)\"]\n  Q   --&gt; C[\"Consented (n=634)\"]\n  C   --&gt; R[\"Randomized (n=534)\"]\n  R   --&gt; TxA[\"A (n=285)\"]\n  R   --&gt; TxB[\"B (n=249)\"]\n  TxA --&gt; FA[\"Finished (n=204)\"]\n  TxB --&gt; FB[\"Finished (n=175)\"]\n  FA  --&gt; OA[\"Outcome assessed (n=196)\"]\n  FB  --&gt; OB[\"Outcome assessed (n=165)\"]\nclassDef largert fill:lightgray,width:1.5in,height:10em,text-align:right,font-size:0.8em;\nclass E largert;\n\n\nFigure 2: Consort diagram produced by mermaid\n\n\n\n\n\n\nCode\n# Create some service functions so later it will be easy to change from\n# mermaid to graphviz\nmakenode       &lt;- function(name, label) paste0(name, '[\"', label, '\"]')\nmakeconnection &lt;- function(from, to)    paste0(from, ' --&gt; ', to)\n\nexclnodes &lt;- function(x, from='E', root='E', seq=FALSE, remain=FALSE) {\n  # Create complete node specifications for individual exclusions, each\n  # linking to overall exclusion count assumed to be in node root.\n  # Set seq=TRUE to make use of the fact that the exclusions were\n  # done in frequency priority order so that each exclusion is in\n  # addition to the previous one.  Leave seq=FALSE to make all exclusions\n  # subservient to root.  Use remain=TRUE to include # obs remaining\n    # remain=TRUE assumes noneNA specified to seqFreq\n  tab &lt;- table(x)\n  i &lt;- 1 : length(tab)\n    rem &lt;- if(remain) paste0(', ', length(x) - cumsum(tab), ' remain')\n  labels &lt;- paste0(names(tab), ' (n=', tab, rem, ')')\n  nodes  &lt;- if(seq) makenode(ifelse(i == 1, paste0(root, '1'), paste0(root, i)),\n                             labels)\n            else    makenode(paste0(root, i), labels)\n  connects &lt;- if(seq) makeconnection(ifelse(i == 1, from, paste0(root, i - 1)),\n                                     paste0(root, i))\n              else makeconnection(from, paste0(root, i))\n   paste(c(nodes, connects), collapse='\\n')\n}\n\n# Create parallel treatment nodes\n# Treatments are assumed to be in order by the tx variable\n# and will appear left to right in the diagram\n# Treatment node names correspond to that and are Tx1, Tx2, ...\n# root: root of new nodes, from: single node name to connect from\n# fromparallel: root of connected-from node name which is to be\n# expanded by adding the integers 1, 2, ... number of treatments.\n\nTxs &lt;- r[, if(is.factor(tx)) levels(tx) else sort(unique(tx))]\n\nparNodes &lt;- function(counts, root, from=NULL, fromparallel=NULL,\n                      label=Txs) {\n  if(! identical(names(counts), Txs)) stop('Txs not consistent')\n  k &lt;- length(Txs)\n  ns &lt;- paste0(' (n=', counts, ')')\n   nodenames &lt;- paste0(root, 1 : k)\n  nodes &lt;- makenode(nodenames, paste0(label, ns))\n  connects &lt;- if(length(fromparallel)) makeconnection(paste0(fromparallel, 1 : k), nodenames)\n              else                     makeconnection(from,                        nodenames)\n  paste(c(nodes, connects), collapse='\\n')\n    }\n\n# Create tooltip text from tabulation created by seqFreq earlier\nefreq &lt;- data.frame('# Exclusions'= (1 : length(eo)) - 1,\n                    '# Subjects'  = eo, check.names=FALSE)\nefreq &lt;- subset(efreq, `# Subjects` &gt; 0)\n# Convert to text which will be wrapped by the html\nexcltab &lt;- paste(capture.output(print(efreq, row.names=FALSE)),\n                 collapse='\\n')\n\n\naddCap('fig-doverview-mermaid2', 'Consort diagram produced with `mermaid` with individual exclusions linked to the overall exclusions node, and with a tooltip to show more detail')\n\nx &lt;- '\nflowchart TD\n  S[\"Screened (n={{N0}})\"] --&gt; E[\"Excluded (n={{Ne}})\"]\n  {{exclsep}}\n  E1 & E2 & E3 --&gt; M[\"{{mult}}\"]\n  S   --&gt; Q[\"Qualified for Randomization (n={{Nq}})\"]\n  Q   --&gt; C[\"Consented (n={{Nc}})\"]\n  C   --&gt; R[\"Randomized (n={{Nr}})\"]\n  {{txcounts}}\n  {{finished}}\n  {{outcome}}\nclick E callback \"{{excltab}}\"\n'\n\nw &lt;- r[, \nmakemermaid(x,\n  N0       = nrow(r),\n  Ne       = count(! is.na(exc)),\n  exclsep  = exclnodes(exc),  # add seq=TRUE to put exclusions vertical\n  excltab  = excltab,         # tooltip text\n  mult     = mult,  # separate node: count multiple exclusions\n  Nq       = count(is.na(exc)),\n  Nc       = count(consent),\n  Nr       = count(randomized),\n  txcounts = parNodes(table(tx),         'Tx', from='R'),\n  finished = parNodes(count(fin, by=tx), 'F',  fromparallel='Tx',\n                      label='Finished'),\n  outcome  = parNodes(count(! is.na(y), by=tx), 'O',\n                      fromparallel='F', label='Outcome assessed'),\n  file='mermaid2.mer'  # save generated code for another use\n)\n]\n\n\nmakenode       &lt;- function(name, label) paste0(name, ' [label=\"', label, '\"];')\nmakeconnection &lt;- function(from, to)    paste0(from, ' -&gt; ', to, ';')\n\n# Create data frame from tabulation created by seqFreq earlier\nefreq &lt;- data.frame('# Exclusions'= (1 : length(eo)) - 1,\n                    '# Subjects'  = eo, check.names=FALSE)\nefreq &lt;- subset(efreq, `# Subjects` &gt; 0)\n\nx &lt;- 'digraph {\n  graph [pad=\"0.5\", nodesep=\"0.5\", ranksep=\"2\", splines=ortho]\n  //  splines=ortho for square connections\n  node  [shape=box, fontsize=\"30\"]\n  rankdir=TD;\n  S [label=\"Screened (n={{N0}})\"];\n  E [label=\"Excluded (n={{Ne}})\"];\n  S -&gt; E;\n  {{exclsep}}\n  M [label=\"{{mult}}\"];\n  E1 -&gt; M;\n  E2 -&gt; M;\n  E3 -&gt; M;\n  Q [label=\"Qualified for Randomization (n={{Nq}})\"];\n  C [label=\"Consented (n={{Nc}})\"];\n  R [label=\"Randomized (n={{Nr}})\"];\n  S -&gt; Q;\n  Q -&gt; C;\n  C -&gt; R;\n  {{txcounts}}\n  {{finished}}\n  {{outcome}}\n  efreq [label=&lt;{{efreq}}&gt;];\n  M -&gt; efreq [dir=none, style=dotted];\n}\n'\n\nw &lt;- r[, \nmakegraphviz(x,\n  N0       = nrow(r),\n  Ne       = count(! is.na(exc)),\n  exclsep  = exclnodes(exc),  # add seq=TRUE to put exclusions vertical\n  efreq    = efreq,\n  mult     = mult,  # separate node: count multiple exclusions\n  Nq       = count(is.na(exc)),\n  Nc       = count(consent),\n  Nr       = count(randomized),\n  txcounts = parNodes(table(tx),         'Tx', from='R'),\n  finished = parNodes(count(fin, by=tx), 'F',  fromparallel='Tx',\n                      label='Finished'),\n  outcome  = parNodes(count(! is.na(y), by=tx), 'O',\n                      fromparallel='F', label='Outcome assessed'),\n  file='graphviz.dot'\n)\n]\n#  addCap('fig-doverview-graphviza', 'Consort diagram produced with `graphviz` with detailed exclusion frequencies in a separate node', scap='Consort diagram produced with `graphviz`')\n\n\n\n\n\n\n\nflowchart TD\n  S[\"Screened (n=1000)\"] --&gt; E[\"Excluded (n=286)\"]\n  E1[\"pain-free (n=156)\"]\nE2[\"age &lt; 40 (n=85)\"]\nE3[\"Hx med (n=45)\"]\nE --&gt; E1\nE --&gt; E2\nE --&gt; E3\n  E1 & E2 & E3 --&gt; M[\"1, 2, ≥3 exclusions: n=260, 25, 1\"]\n  S   --&gt; Q[\"Qualified for Randomization (n=714)\"]\n  Q   --&gt; C[\"Consented (n=634)\"]\n  C   --&gt; R[\"Randomized (n=534)\"]\n  Tx1[\"A (n=285)\"]\nTx2[\"B (n=249)\"]\nR --&gt; Tx1\nR --&gt; Tx2\n  F1[\"Finished (n=204)\"]\nF2[\"Finished (n=175)\"]\nTx1 --&gt; F1\nTx2 --&gt; F2\n  O1[\"Outcome assessed (n=196)\"]\nO2[\"Outcome assessed (n=165)\"]\nF1 --&gt; O1\nF2 --&gt; O2\nclick E callback \" # Exclusions # Subjects\n            0        714\n            1        260\n            2         25\n            3          1\"\n\n\nFigure 3: Consort diagram produced with mermaid with individual exclusions linked to the overall exclusions node, and with a tooltip to show more detail\n\n\n\n\n\n\nCode\ngetHdata(support)\nsetDT(support)\n# addCap('fig-doverview-missflow', 'Flowchart of sequential exclusion of observations due to missing values')\nvars &lt;-  .q(age, sex, dzgroup, edu, income, meanbp, wblc,\n            alb, bili, crea, glucose, bun, urine)\nex &lt;- missChk(support, use=vars, type='seq') # seq: don't make report\n\n# Create tooltip text from tabulation created by seqFreq\noc   &lt;- attr(ex, 'obs.per.numcond')\nfreq &lt;- data.frame('# Exclusions'= (1 : length(oc)) - 1,\n                   '# Subjects'  = oc, check.names=FALSE)\nfreq &lt;- subset(freq, `# Subjects` &gt; 0)\n\nx &lt;- '\ndigraph {\n  graph [pad=\"0.5\", nodesep=\"0.5\", ranksep=\"2\", splines=ortho]\n  //  splines=ortho for square connections\n  node  [shape=box, fontsize=\"30\"]\n  rankdir=TD;\n  Enr [label=\"Enrolled (n={{N0}})\"];\n  Enr;\n  {{exclsep}}\n    Extab [label=&lt;{{excltab}}&gt;];\n  Enr:e -&gt; Extab [dir=none];\n}\n'\nmakegraphviz(x,\n  N0        = nrow(support),\n  exclsep   = exclnodes(ex, from='Enr', seq=TRUE, remain=TRUE),\n  excltab   = freq,\n  file      = 'support.dot'\n)\n\n\n\n\nCode\ngrViz('\ngraph G {\nfontname=\"Helvetica,Arial,sans-serif\"\nnode [fontname=\"Helvetica,Arial,sans-serif\"]\nedge [fontname=\"Helvetica,Arial,sans-serif\"]\nI5 [shape=ellipse,color=red,style=bold,label=\"Caroline Bouvier Kennedy\\nb. 27.11.1957 New York\",image=\"images/165px-Caroline_Kennedy.jpg\",labelloc=b];\nI1 [shape=box,color=blue,style=bold,label=\"John Fitzgerald Kennedy\\nb. 29.5.1917 Brookline\\nd. 22.11.1963 Dallas\",image=\"images/kennedyface.jpg\",labelloc=b];\nI6 [shape=box,color=blue,style=bold,label=\"John Fitzgerald Kennedy\\nb. 25.11.1960 Washington\\nd. 16.7.1999 over the Atlantic Ocean, near Aquinnah, MA, USA\",image=\"images/180px-JFKJr2.jpg\",labelloc=b];\nI7 [shape=box,color=blue,style=bold,label=\"Patrick Bouvier Kennedy\\nb. 7.8.1963\\nd. 9.8.1963\"];\nI2 [shape=ellipse,color=red,style=bold,label=\"Jaqueline Lee Bouvier\\nb. 28.7.1929 Southampton\\nd. 19.5.1994 New York City\",image=\"images/jacqueline-kennedy-onassis.jpg\",labelloc=b];\nI8 [shape=box,color=blue,style=bold,label=\"Joseph Patrick Kennedy\\nb. 6.9.1888 East Boston\\nd. 16.11.1969 Hyannis Port\",image=\"images/1025901671.jpg\",labelloc=b];\nI10 [shape=box,color=blue,style=bold,label=\"Joseph Patrick Kennedy Jr\\nb. 1915\\nd. 1944\"];\nI11 [shape=ellipse,color=red,style=bold,label=\"Rosemary Kennedy\\nb. 13.9.1918\\nd. 7.1.2005\",image=\"images/rosemary.jpg\",labelloc=b];\nI12 [shape=ellipse,color=red,style=bold,label=\"Kathleen Kennedy\\nb. 1920\\nd. 1948\"];\nI13 [shape=ellipse,color=red,style=bold,label=\"Eunice Mary Kennedy\\nb. 10.7.1921 Brookline\"];\nI9 [shape=ellipse,color=red,style=bold,label=\"Rose Elizabeth Fitzgerald\\nb. 22.7.1890 Boston\\nd. 22.1.1995 Hyannis Port\",image=\"images/Rose_kennedy.JPG\",labelloc=b];\nI15 [shape=box,color=blue,style=bold,label=\"Aristotle Onassis\"];\nI3 [shape=box,color=blue,style=bold,label=\"John Vernou Bouvier III\\nb. 1891\\nd. 1957\",image=\"images/BE037819.jpg\",labelloc=b];\nI4 [shape=ellipse,color=red,style=bold,label=\"Janet Norton Lee\\nb. 2.10.1877\\nd. 3.1.1968\",image=\"images/n48862003257_1275276_1366.jpg\",labelloc=b];\n I1 -- I5  [style=bold,color=blue]; \n I1 -- I6  [style=bold,color=orange]; \n I2 -- I6  [style=bold,color=orange]; \n I1 -- I7  [style=bold,color=orange]; \n I2 -- I7  [style=bold,color=orange]; \n I1 -- I2  [style=bold,color=violet]; \n I8 -- I1  [style=bold,color=blue]; \n I8 -- I10  [style=bold,color=orange]; \n I9 -- I10  [style=bold,color=orange]; \n I8 -- I11  [style=bold,color=orange]; \n I9 -- I11  [style=bold,color=orange]; \n I8 -- I12  [style=bold,color=orange]; \n I9 -- I12  [style=bold,color=orange]; \n I8 -- I13  [style=bold,color=orange]; \n I9 -- I13  [style=bold,color=orange]; \n I8 -- I9  [style=bold,color=violet]; \n I9 -- I1  [style=bold,color=red]; \n I2 -- I5  [style=bold,color=red]; \n I2 -- I15  [style=bold,color=violet]; \n I3 -- I2  [style=bold,color=blue]; \n I3 -- I4  [style=bold,color=violet]; \n I4 -- I2  [style=bold,color=red]; \n}')"
  },
  {
    "objectID": "Visuals_Interactives/tikz_net.html",
    "href": "Visuals_Interactives/tikz_net.html",
    "title": "tikz",
    "section": "",
    "text": "https://www.andrewheiss.com/blog/2021/08/27/tikz-knitr-html-svg-fun/ https://gist.github.com/andrewheiss/4ece621813a27dfdcaef7f1c2d773237\nCode\n```{r}\n#lapply(c('tidyverse','data.table','igraph','ggraph','kableExtra'),library,character.only=TRUE))\npacman::p_load(tikzDevice, knitr) \n```"
  },
  {
    "objectID": "Visuals_Interactives/tikz_net.html#intro",
    "href": "Visuals_Interactives/tikz_net.html#intro",
    "title": "tikz",
    "section": "Intro",
    "text": "Intro\nHere is a TikZ picture\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: true\n\\tikzset{\n    declare function={\n        sig = 0.1;\n        mu = 0;\n        g(\\x) = 1/(sig*sqrt(2*pi)) * exp(-1/2 * ((\\x-mu)/sig)^2);\n    }\n}\n\n\n\n\\begin{tikzpicture}[\n    shorten &gt;=1pt,\n    -&gt;,\n    draw=black!50,\n    node distance=2.5cm,\n    scale=1.5,\n    every pin edge/.style={&lt;-,shorten &lt;=1pt},\n    neuron/.style={\n        circle,fill=black!25,minimum size=17pt,inner sep=0pt,\n        path picture={\n            \\draw[red,thick,-] plot[domain=-0.3:0.3,samples=11,smooth] ({\\x},{0.05*g(\\x)});\n        },\n    },\n    input neuron/.style={neuron, fill=green!50},\n    output neuron/.style={neuron, fill=red!50},\n    hidden neuron/.style={neuron, fill=blue!50},\n    annot/.style={text width=4em, text centered},\n]\n\n    % Draw the input layer nodes\n    \\foreach \\name / \\y in {1,...,4}\n    % This is the same as writing \\foreach \\name / \\y in {1/1,2/2,3/3,4/4}\n        \\node[input neuron, pin=left:Input \\y] (I-\\name) at (0,-\\y) {};\n    \n    % Draw the hidden layer nodes\n    \\foreach \\name / \\y in {1,...,5}\n        \\path[yshift=0.5cm]\n            node[hidden neuron] (H-\\name) at (2.5cm,-\\y cm) {};\n    \n    % Draw the output layer node\n    \\node[output neuron,pin={[pin edge={-&gt;}]right:Output}, right of=H-3] (O) {};\n    \n    % Connect every node in the input layer with every node in the\n    % hidden layer.\n    \\foreach \\source in {1,...,4}\n        \\foreach \\dest in {1,...,5}\n            \\path (I-\\source) edge (H-\\dest);\n    \n    % Connect every node in the hidden layer with the output layer\n    \\foreach \\source in {1,...,5}\n        \\path (H-\\source) edge (O);\n    \n    % Annotate the layers\n    \\node[annot,above of=H-1, node distance=1cm] (hl) {Hidden layer};\n    \\node[annot,above of=I-1, node distance=1cm] {Input layer};\n    \\node[annot,above of=O] {Output layer};\n\n\n\\end{tikzpicture}\n\n```\n\n\n\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: true\n#| cache: true\n\n\n\\usetikzlibrary{matrix,chains,positioning,decorations.pathreplacing,arrows}\n\n\\begin{tikzpicture}[\n    init/.style={\n      draw,\n      circle,\n      inner sep=2pt,\n      font=\\Huge,\n      join = by -latex\n    },\n    squa/.style={\n      draw,\n      inner sep=2pt,\n      font=\\Large,\n      join = by -latex\n    },\n    start chain=2,node distance=13mm\n    ]\n    \\node[on chain=2] \n      (x2) {$x_2$};\n    \\node[on chain=2,join=by o-latex] \n      {$w_2$};\n    \\node[on chain=2,init] (sigma) \n      {$\\displaystyle\\Sigma$};\n    \\node[on chain=2,squa,label=above:{\\parbox{2cm}{\\centering Activate \\\\ function}}]   \n      {$f$};\n    \\node[on chain=2,label=above:Output,join=by -latex] \n      {$y$};\n    \\begin{scope}[start chain=1]\n    \\node[on chain=1] at (0,1.5cm) \n      (x1) {$x_1$};\n    \\node[on chain=1,join=by o-latex] \n      (w1) {$w_1$};\n    \\end{scope}\n    \\begin{scope}[start chain=3]\n    \\node[on chain=3] at (0,-1.5cm) \n      (x3) {$x_3$};\n    \\node[on chain=3,label=below:Weights,join=by o-latex] \n      (w3) {$w_3$};\n    \\end{scope}\n    \\node[label=above:\\parbox{2cm}{\\centering Bias \\\\ $b$}] at (sigma|-w1) (b) {};\n    \n    \\draw[-latex] (w1) -- (sigma);\n    \\draw[-latex] (w3) -- (sigma);\n    \\draw[o-latex] (b) -- (sigma);\n    \n    \\draw[decorate,decoration={brace,mirror}] (x1.north west) -- node[left=10pt] {Inputs} (x3.south west);\n\\end{tikzpicture}\n\n```\n\n\n\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: true\n#| cache: true\n\n\\usetikzlibrary{positioning}\n\n\\tikzset{basic/.style={draw,fill=blue!20,text width=1em,text badly centered}}\n\\tikzset{input/.style={basic,circle}}\n\\tikzset{weights/.style={basic,rectangle}}\n\\tikzset{functions/.style={basic,circle,fill=blue!10}}\n\n\n\\begin{tikzpicture}\n    \\node[functions] (center) {};\n    \\node[below of=center,font=\\scriptsize,text width=4em] {Activation function};\n    \\draw[thick] (0.5em,0.5em) -- (0,0.5em) -- (0,-0.5em) -- (-0.5em,-0.5em);\n    \\draw (0em,0.75em) -- (0em,-0.75em);\n    \\draw (0.75em,0em) -- (-0.75em,0em);\n    \\node[right of=center] (right) {};\n        \\path[draw,-&gt;] (center) -- (right);\n    \\node[functions,left=3em of center] (left) {$\\sum$};\n        \\path[draw,-&gt;] (left) -- (center);\n    \\node[weights,left=3em of left] (2) {$w_2$} -- (2) node[input,left of=2] (l2) {$x_2$};\n        \\path[draw,-&gt;] (l2) -- (2);\n        \\path[draw,-&gt;] (2) -- (left);\n    \\node[below of=2] (dots) {$\\vdots$} -- (dots) node[left of=dots] (ldots) {$\\vdots$};\n    \\node[weights,below of=dots] (n) {$w_n$} -- (n) node[input,left of=n] (ln) {$x_n$};\n        \\path[draw,-&gt;] (ln) -- (n);\n        \\path[draw,-&gt;] (n) -- (left);\n    \\node[weights,above of=2] (1) {$w_1$} -- (1) node[input,left of=1] (l1) {$x_1$};\n        \\path[draw,-&gt;] (l1) -- (1);\n        \\path[draw,-&gt;] (1) -- (left);\n    \\node[weights,above of=1] (0) {$w_0$} -- (0) node[input,left of=0] (l0) {$1$};\n        \\path[draw,-&gt;] (l0) -- (0);\n        \\path[draw,-&gt;] (0) -- (left);\n    \\node[below of=ln,font=\\scriptsize] {inputs};\n    \\node[below of=n,font=\\scriptsize] {weights};\n\\end{tikzpicture}\n\n```\n\n\n\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: true\n#| cache: true\n\n\\usetikzlibrary{%\n  calc,\n  fit,\n  shapes,\n  backgrounds\n}\n% the next macro is useful to create a table\n\\newcommand\\tabins[3]{%\n \\tikz[baseline=(Tab.base)] \n           \\node  [rectangle split, \n                   rectangle split parts=3, \n                   draw, \n                   align=right,\n                   inner sep=.5em,\n                   rectangle split horizontal] (Tab)\n                           {\\hbox to 4ex{#1}\n           \\nodepart{two}  {\\hbox to 8ex{\\hfill #2\\$}}  \n           \\nodepart{three}{\\hbox to 3ex{#3}}}; \n}\n\n\n\\parindent=0pt\n\n\\begin{tikzpicture}[%\n    %every node/.style={transform shape},% now is not necessary but good for a poster\n    x=1.25cm,y=2cm,  \n    font=\\footnotesize,\n    % every group of nodes have a style except for main, the style is named by a letter\n    main/.style={draw,fill=yellow,inner sep=.5em},\n    R/.style={draw,fill=purple!40!blue!30,inner sep=.5em},\n    M/.style={draw,fill=green!80!yellow,inner sep=.5em},\n    S/.style={anchor=east},\n    V/.style={anchor=west},\n    P/.style={anchor=center},\n    F/.style={anchor=west}\n    ]\n\n  % main node the reference Shuffle \n  \\node[main] (shuffle) {Group};\n  %group R reducer\n  \\node[R] at ($(shuffle)+(8,1)$)    (R1+) {Reduce};\n  \\node[R] at ($(shuffle)+(8, 0)$)   (R0)  {Reduce};\n  \\node[R] at ($(shuffle)+(8,-1)$)   (R1-) {Reduce};\n  % group M Mapper\n  \\node[M] at ($(shuffle)+(-6,+2.5)$)   (M3+)  {Map};\n  \\node[M] at ($(shuffle)+(-6,+ 1.5)$)  (M2+)  {Map};\n  \\node[M] at ($(shuffle)+(-6,+ .5)$)   (M1+)  {Map};\n  \\node[M] at ($(shuffle)+(-6,- .5)$)   (M1-)  {Map};\n  \\node[M] at ($(shuffle)+(-6,- 1.5)$)  (M2-)  {Map};\n  \\node[M] at ($(shuffle)+(-6,-2.5)$)   (M3-)  {Map};\n  % group S Start the first nodes\n  \\node[S] at ($(M3+)+(-1.5,0)$)  (S3+) {\\Big($k_1$,\\tabins{4711}{59.90}{NY}\\Big)};\n  \\node[S] at ($(M2+)+(-1.5,0)$)  (S2+) {\\Big($k_2$,\\tabins{4713}{142.99}{CA}\\Big)};\n  \\node[S] at ($(M1+)+(-1.5,0)$)  (S1+) {\\Big($k_3$,\\tabins{4714}{72.00}{NY}\\Big)}; \n  \\node[S] at ($(M1-)+(-1.5,0)$)  (S1-) {\\Big($k_4$,\\tabins{4715}{108.75}{NY}\\Big)}; \n  \\node[S] at ($(M2-)+(-1.5,0)$)  (S2-) {\\Big($k_5$,\\tabins{4718}{19.89}{WA}\\Big)};  \n  \\node[S] at ($(M3-)+(-1.5,0)$)  (S3-) {\\Big($k_6$,\\tabins{4719}{36.60}{CA}\\Big)};  \n  % group V  why not\n  \\node[V] at ($(M3+)+(1.5,0)$)  (V3+) {\\Big(NY,59.90\\$\\Big)};\n  \\node[V] at ($(M2+)+(1.5,0)$)  (V2+) {\\Big(CA,142.99\\$\\Big)};\n  \\node[V] at ($(M1+)+(1.5,0)$)  (V1+) {\\Big(NY,72.00\\$\\Big)}; \n  \\node[V] at ($(M1-)+(1.5,0)$)  (V1-) {\\Big(NY,108.75\\$\\Big)}; \n  \\node[V] at ($(M2-)+(1.5,0)$)  (V2-) {\\Big(WA,19.89\\$\\Big)};  \n  \\node[V] at ($(M3-)+(1.5,0)$)  (V3-) {\\Big(CA,36.60\\$\\Big)};   \n\n  \\node[P] at ($(R1+)+(-4,0)$) (P1+) {\\Big(CA,\\big[142.99\\$,36.60\\$\\big]\\Big)};\n  \\node[P] at ($(R0) +(-4,0)$) (P0)  {\\Big(NY,\\big[59.90\\$,72.00\\$,108.75\\big]\\Big)};\n  \\node[P] at ($(R1-)+(-4,0)$) (P1-) {\\Big(WA,\\big[19.89\\$\\big]\\Big)}; \n\n  \\node[F] (F1+) at ($(R1+)+(1.5,0)$) {(CA,89.80\\$)};\n  \\node[F] (F0)  at ($(R0) +(1.5,0)$) {(NY,80.22\\$)}; \n  \\node[F] (F1-) at ($(R1-)+(1.5,0)$) {(WA,72.00\\$)}; \n\n  % wrappers\n  \\begin{scope}[on background layer]\n      \\node[fill=lightgray!50,inner sep = 4mm,fit=(shuffle),label=above:Shuffle] {}; \n  \\end{scope} \n  \\begin{scope}[on background layer]\n      \\node[fill=lightgray!50,inner sep = 4mm,fit=(R1+)(R1-),label=above:Reducer] {}; \n  \\end{scope}  \n  \\begin{scope}[on background layer]\n      \\node[fill=lightgray!50,inner sep = 4mm,fit=(M3+)(M3-),label=above:Mapper] {}; \n  \\end{scope}\n\n  %edges\n\n  \\foreach \\indice in {3+,2+,1+,1-,2-,3-} \\draw[-&gt;] (S\\indice.east) -- (M\\indice.west); \n  \\foreach \\indice in {3+,2+,1+,1-,2-,3-} \\draw[-&gt;] (M\\indice.east) -- (V\\indice.west);\n  \\foreach \\indice in {3+,2+,1+,1-,2-,3-} \\draw[-&gt;] (V\\indice.east) to [out=0,in=180] (shuffle.west); \n  \\foreach \\indice in {1+,0,1-} \\draw[-&gt;] (shuffle.east) to [out=0,in=180] (P\\indice.west);  \n  \\foreach \\indice in {1+,0,1-} \\draw[-&gt;] (P\\indice.east) -- (R\\indice.west);\n  \\foreach \\indice in {1+,0,1-} \\draw[-&gt;] (R\\indice.east) -- (F\\indice.west);   \n\\end{tikzpicture} \n\n```\n\n\n\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: true\n#| cache: true\n#|\n\\def\\layersep{3cm}\n\\def\\nodeinlayersep{1.5cm}\n\n\\begin{tikzpicture}\n  [\n    shorten &gt;=1pt,-&gt;,\n    draw=black!50,\n    node distance=\\layersep,\n    every pin edge/.style={&lt;-,shorten &lt;=1pt},\n    neuron/.style={circle,fill=black!25,minimum size=17pt,inner sep=0pt},\n    input neuron/.style={neuron, fill=green!50,},\n    output neuron/.style={neuron, fill=red!50},\n    hidden neuron/.style={neuron, fill=blue!50},\n    annot/.style={text width=4em, text centered},\n    bias/.style={neuron, fill=yellow!50,minimum size=4em},%&lt;-- added %%%\n  ]\n\n  % Draw the input layer nodes\n  \\foreach \\name / \\y in {1,...,3}\n    \\node[input neuron, pin=left:Input \\#\\y] (I-\\name) at (0,-\\y-2.5) {};  \n\n  % set number of hidden layers\n  \\newcommand\\Nhidden{2}\n\n  % Draw the hidden layer nodes\n  \\foreach \\N in {0,...,\\Nhidden} {\n      \\foreach \\y in {0,...,5} { % &lt;-- added 0 instead of 1 %%%%%\n      \\ifnum \\y=4\n      \\ifnum \\N&gt;0 %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        \\node at (\\N*\\layersep,-\\y*\\nodeinlayersep) {$\\vdots$};  % add dots\n        \\else\\fi %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n      \\else\n          \\ifnum \\y=0 %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          \\ifnum \\N&lt;3 %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n            \\node[bias] (H\\N-\\y) at (\\N*\\layersep,-\\y*\\nodeinlayersep ) {Bias}; %&lt;-- added\n            \\else\\fi %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          \\else %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n            \\ifnum \\N&gt;0 %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%%%\n            % print function\n            \\node[hidden neuron] (H\\N-\\y) at (\\N*\\layersep,-\\y*\\nodeinlayersep ) {$\\frac{1}{1+e^{-x}}$}; %&lt;-- added %%%%%%%%%%%\n                \\else\\fi %&lt;-- added %%%%%%%%%%%%\n          \\fi %&lt;-- added %%%%%%%\n      \\fi\n    }\n      \\ifnum \\N&gt;0 %&lt;-- added %%%%%%\n      % print hidden layer labels at the top\n    \\node[annot,above of=H\\N-1, node distance=1cm,yshift=2cm] (hl\\N) {Hidden layer \\N}; % &lt;- added yshift=2cm %%%%%%%%%%%%\n    \\else\\fi %&lt;-- added %%%%%\n  }\n\n  % Draw the output layer node and label\n  \\node[output neuron,pin={[pin edge={-&gt;}]right:Output}, right of=H\\Nhidden-3] (O) {}; \n  \n  % Connect bias every node in the input layer with every node in the\n  % hidden layer.\n  \\foreach \\source in {1,...,3}\n      \\foreach \\dest in {1,...,3,5} {\n        % \\path[yellow] (H-0) edge (H1-\\dest);\n        \\path[dashed,orange] (H0-0) edge (H1-\\dest); %&lt;-- added %%%%%\n          \\path[green!50] (I-\\source) edge (H1-\\dest);  % change to green, yellow gets blended\n    };\n\n  % connect all hidden stuff\n  \\foreach [remember=\\N as \\lastN (initially 1)] \\N in {2,...,\\Nhidden}\n      \\foreach \\source in {0,...,3,5} \n          \\foreach \\dest in {1,...,3,5}{\n              \\ifnum \\source=0 %&lt;-- added %%%%%%%%%%%%%%%%%%%%%%%\n          \\path[dashed,red](H\\lastN-\\source) edge (H\\N-\\dest);%&lt;-- added \n            \\else %&lt;-- added %%%\n            \\path[blue!50] (H\\lastN-\\source) edge (H\\N-\\dest);%&lt;-- added \n            \\fi %&lt;-- added %%%\n            }; %&lt;-- added %%%%\n\n\n  % Connect every node in the hidden layer with the output layer\n  \\foreach \\source in {1,...,3,5}\n    \\path[green!50] (H\\Nhidden-\\source) edge (O);\n    \\path[dashed,red] (H2-0) edge (O); %&lt;-- added %%%%\n\n% Annotate the input and output layers\n  \\node[annot,left of=hl1] {Input layer};\n  \\node[annot,right of=hl\\Nhidden] {Output layer};  \n\\end{tikzpicture}\n\n```\n\n\n\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: true\n#| cache: true\n\n\\usetikzlibrary{positioning}\n\n\\tikzstyle{inputNode}=[draw,circle,minimum size=10pt,inner sep=0pt]\n\\tikzstyle{stateTransition}=[-stealth, thick]\n\n\\begin{tikzpicture}\n    \\node[draw,circle,minimum size=25pt,inner sep=0pt] (x) at (0,0) {$\\Sigma$ $\\sigma$};\n\n    \\node[inputNode] (x0) at (-2, 1.5) {$\\tiny +1$};\n    \\node[inputNode] (x1) at (-2, 0.75) {$\\tiny x_1$};\n    \\node[inputNode] (x2) at (-2, 0) {$\\tiny x_2$};\n    \\node[inputNode] (x3) at (-2, -0.75) {$\\tiny x_3$};\n    \\node[inputNode] (xn) at (-2, -1.75) {$\\tiny x_n$};\n\n    \\draw[stateTransition] (x0) to[out=0,in=120] node [midway, sloped, above] {$w_0$} (x);\n    \\draw[stateTransition] (x1) to[out=0,in=150] node [midway, sloped, above] {$w_1$} (x);\n    \\draw[stateTransition] (x2) to[out=0,in=180] node [midway, sloped, above] {$w_2$} (x);\n    \\draw[stateTransition] (x3) to[out=0,in=210] node [midway, sloped, above] {$w_3$} (x);\n    \\draw[stateTransition] (xn) to[out=0,in=240] node [midway, sloped, above] {$w_n$} (x);\n    \\draw[stateTransition] (x) -- (4,0) node [midway,above] {$\\sigma\\left(w_0 + \\sum\\limits_{i=1}^{n}{w_ix_i}\\right)$};\n    \\draw[dashed] (0,-0.43) -- (0,0.43);\n    \\node (dots) at (-2, -1.15) {$\\vdots$};\n    \\node[inputNode, thick] (i1) at (6, 0.75) {};\n    \\node[inputNode, thick] (i2) at (6, 0) {};\n    \\node[inputNode, thick] (i3) at (6, -0.75) {};\n    \n    \\node[inputNode, thick] (h1) at (8, 1.5) {};\n    \\node[inputNode, thick] (h2) at (8, 0.75) {};\n    \\node[inputNode, thick] (h3) at (8, 0) {};\n    \\node[inputNode, thick] (h4) at (8, -0.75) {};\n    \\node[inputNode, thick] (h5) at (8, -1.5) {};\n    \n    \\node[inputNode, thick] (o1) at (10, 0.75) {};\n    \\node[inputNode, thick] (o2) at (10, -0.75) {};\n    \n    \\draw[stateTransition] (5, 0.75) -- node[above] {$I_1$} (i1);\n    \\draw[stateTransition] (5, 0) -- node[above] {$I_2$} (i2);\n    \\draw[stateTransition] (5, -0.75) -- node[above] {$I_3$} (i3);\n    \n    \\draw[stateTransition] (i1) -- (h1);\n    \\draw[stateTransition] (i1) -- (h2);\n    \\draw[stateTransition] (i1) -- (h3);\n    \\draw[stateTransition] (i1) -- (h4);\n    \\draw[stateTransition] (i1) -- (h5);\n    \\draw[stateTransition] (i2) -- (h1);\n    \\draw[stateTransition] (i2) -- (h2);\n    \\draw[stateTransition] (i2) -- (h3);\n    \\draw[stateTransition] (i2) -- (h4);\n    \\draw[stateTransition] (i2) -- (h5);\n    \\draw[stateTransition] (i3) -- (h1);\n    \\draw[stateTransition] (i3) -- (h2);\n    \\draw[stateTransition] (i3) -- (h3);\n    \\draw[stateTransition] (i3) -- (h4);\n    \\draw[stateTransition] (i3) -- (h5);\n    \n    \\draw[stateTransition] (h1) -- (o1);\n    \\draw[stateTransition] (h1) -- (o2);\n    \\draw[stateTransition] (h2) -- (o1);\n    \\draw[stateTransition] (h2) -- (o2);\n    \\draw[stateTransition] (h3) -- (o1);\n    \\draw[stateTransition] (h3) -- (o2);\n    \\draw[stateTransition] (h4) -- (o1);\n    \\draw[stateTransition] (h4) -- (o2);\n    \\draw[stateTransition] (h5) -- (o1);\n    \\draw[stateTransition] (h5) -- (o2);\n    \n    \\node[above=of i1, align=center] (l1) {Input \\\\ layer};\n    \\node[right=2.3em of l1, align=center] (l2) {Hidden \\\\ layer};\n    \\node[right=2.3em of l2, align=center] (l3) {Output \\\\ layer};\n    \n    \\draw[stateTransition] (o1) -- node[above] {$O_1$} (11, 0.75);\n    \\draw[stateTransition] (o2) -- node[above] {$O_2$} (11, -0.75);\n    \n    \\path[dashed, double, ultra thick, gray] (x.north) edge[bend left=0] (h5.north);\n    \\path[dashed, double, ultra thick, gray] (x.south) edge[bend right=0] (h5.south);\n\\end{tikzpicture}\n\n```\n\n\n\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: false\n\n\\usetikzlibrary{positioning,decorations.pathreplacing,shapes}\n\n\n\\newcommand*{\\cancer}{\\text{cancer}}\n\\newcommand*{\\testp}{\\text{test}+}\n\n\n\\begin{tikzpicture}[%\n   % common options for blocks:\n   block/.style = {draw, fill=blue!30, align=center, anchor=west,\n               minimum height=0.65cm, inner sep=0},\n   % common options for the circles:\n   ball/.style = {circle, draw, align=center, anchor=north, inner sep=0}]\n\n   % circle illustrating all women\n   \\node[ball,text width=3cm,fill=purple!20] (all) at (6,0) {All women};\n\n   % two circles showing split of p{cancer} and p{~cancer}\n   \\node[ball,fill=red!70,text width=0.1cm,anchor=base] (pcan) at (3.5,-5.5) {};\n   \\node[ball,fill=blue!40,text width=2.9cm,anchor=base] (pncan) at (8.5,-6)\n      {Women without cancer\\\\\n      $\\p({\\sim}\\cancer) = 99\\%$};\n\n   % arrows showing split from all women to cancer and ~cancer\n   \\draw[-&gt;,thick,draw=red!50] (all.south) to [out=270,in=90] (pcan.north);\n   \\draw[-&gt;,thick,draw=blue!80] (all.south) to [out=270,in=110] (pncan.100);\n\n   % transition from all women to actual cancer rates\n   \\node[anchor=north,text width=10cm,inner sep=.05cm,align=center,fill=white]\n   (why1) at (6,-3.7) {In measuring, we find:};\n\n   % note illustration the p{cancer} circle (text wont fit inside)\n   \\node[inner sep=0,anchor=east,text width=3.3cm] (note1) at (3.2,-5.5) {\n      Women with cancer $\\p(\\cancer) = 1\\%$};\n\n   % draw the sieves\n   \\node[block,anchor=north,text width=4.4cm,fill=green!50] (tray1) at\n      (3.5,-8.8) {\\small{$\\p(\\testp\\mid\\cancer)=0.8$}};\n\n   \\node[block,anchor=north,text width=4.4cm,fill=green!50] (tray2) at\n      (8.5,-8.8) {$\\p(\\testp\\mid{\\sim}\\cancer)=0.096$};\n\n   % text explaining how p{cancer} and p{~cancer} behave as they\n   % pass through the sieves\n   \\node[anchor=west,text width=6cm] (note1) at (-6,-9.1) {\n      Now we pass both groups through the sieve; note that both\n      sieves are \\emph{the same}; they just behave differently\n      depending on which group is passing through. \\\\ \n      Let $\\testp=$ a positve mammography.};\n\n   % arrows showing the circles passing through the seives\n   \\draw[-&gt;,thick,draw=red!80] (3.5,-5.9) -- (3.5,-8.6);\n   \\draw[-&gt;,thick,draw=blue!50] (8.5,-8.1) -- (8.5,-8.6);\n\n   % numerator\n   \\node[ball,text width=0.05cm,fill=red!70] (can) at (6,-10.5) {};\n\n   % dividing line\n   \\draw[thick] (5,-11) -- (7,-11);\n\n   % demoniator\n   \\node[ball,text width=0.39cm,fill=blue!40,anchor=base] (ncan) at (6.5,-11.5) {};\n   \\node[ball,text width=0.05cm,fill=red!70,anchor=base] (can2) at (5.5,-11.5) {};\n\n   % plus sign in denominator\n   \\draw[thick] (5.9,-11.4) -- (5.9,-11.6);\n   \\draw[thick] (5.8,-11.5) -- (6,-11.5);\n\n   % arrows showing the output of the sieves formed the fraction\n   \\draw[-&gt;,thick,draw=red!80] (tray1.south) to [out=280,in=180] (can);\n   \\draw[-&gt;,thick,draw=red!80] (tray1.south) to [out=280,in=180] (can2);\n   \\node[anchor=north,inner sep=.1cm,align=center,fill=white] (why2) at\n      (3.8,-9.8) {$1\\% * 80\\%$};\n\n   \\draw[-&gt;,thick,draw=blue!50] (tray2.south) to [out=265,in=0] (ncan);\n   \\node[anchor=north,inner sep=.1cm,align=center,fill=white] (why2) at\n      (8.4,-9.8) {$99\\% * 9.6\\%$};\n\n   % explanation of final formula\n   \\node[anchor=north west,text width=6.5cm] (note2) at (-6,-12.5)\n      {Finally, to find the probability that a positive test\n         \\emph{actually means cancer}, we look at those who passed\n         through the sieve \\emph{with cancer}, and divide by all who\n         received a positive test, cancer or not.}; \n\n   % illustrated fraction turned into math\n   \\node[anchor=north,text width=10cm] (solution) at (6,-12.5) {\n   \\begin{align*}\n         \\frac{\\p(\\testp\\mid\\cancer)}{\\p(\\testp\\mid\\cancer)\n         + \\p(\\testp\\mid{\\sim}\\cancer)} &= \\\\\n         \\frac{1\\% * 80\\%}{(1\\% * 80\\%) + (99\\% * 9.6\\%)} &= 7.8\\%\n         = \\p(\\cancer\\mid\\testp)\n      \\end{align*}};\n\\end{tikzpicture}\n\n```\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: false\n\n\n# \\usetikzlibrary{arrows}\n# \\usetikzlibrary{positioning}\n# \\usetikzlibrary{calc}\n# \\usetikzlibrary{arrows.meta}\n# \\usetikzlibrary{decorations.pathreplacing}\n\n# \\begin{tikzpicture}\n# \\draw (0,0)node(a){} -- (10,0) node (b) {} ;\n# \\foreach \\x in  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} % edit here for the vertical lines\n# \\draw[shift={(\\x,0)},color=black] (0pt,3pt) -- (0pt,-3pt);\n# \\foreach \\x in {0, 0.2, 0.4, 0.6, 0.8, 1} % edit here for the numbers\n# \\draw[shift={(\\x*10,0)},color=black] (0pt,0pt) -- (0pt,-3pt) node[below]\n# {$\\x$};\n# \\node at (8, 0.5) (eq1) {$\\textcolor{red}{\\boldsymbol{SQ}}$};\n# \\node at (4, 0.5) (eq2) {$\\textcolor{purple}{\\boldsymbol{G_i(0)}}$}; \n# \\node at (7, 0.5) (eq2) {$\\textcolor{purple}{\\boldsymbol{G_i(1)}}$}; \n# \\node at (3, 0.5) (eq3) {$\\textcolor{blue}{\\boldsymbol{P}}$};\n# \\node at (0, 0.5) (eq4) {$\\textcolor{black}{\\boldsymbol{x_i}}$};\n# \\draw[decorate, decoration={brace, amplitude=6pt, mirror},] ([yshift=0.5cm]4,0.5)-- node[above=0.25cm]\n# {\\shortstack{Text}}([yshift=0.5cm]3,0.5);\n# \\draw[decorate, decoration={brace, amplitude=6pt},] ([yshift=-1cm]7,0)-- node[below=0.25cm]\n# {\\shortstack{Text}}([yshift=-1cm]3,0);\n# \\end{tikzpicture}\n```\n\n\n\nTikz Neural Networks\nhttps://tikz.net/neural_networks/\n\n\nCode\n```{r, engine = 'tikz', engine.opts=font_opts2, cache=TRUE}\n#| cache: true\n\n\\usetikzlibrary{arrows.meta} % for arrow size\n\n\\tikzset{&gt;=latex} % for LaTeX arrow head\n\\colorlet{myred}{red!80!black}\n\\colorlet{myblue}{blue!80!black}\n\\colorlet{mygreen}{green!60!black}\n\\colorlet{myorange}{orange!70!red!60!black}\n\\colorlet{mydarkred}{red!30!black}\n\\colorlet{mydarkblue}{blue!40!black}\n\\colorlet{mydarkgreen}{green!30!black}\n\\tikzstyle{node}=[thick,circle,draw=myblue,minimum size=22,inner sep=0.5,outer sep=0.6]\n\\tikzstyle{node in}=[node,green!20!black,draw=mygreen!30!black,fill=mygreen!25]\n\\tikzstyle{node hidden}=[node,blue!20!black,draw=myblue!30!black,fill=myblue!20]\n\\tikzstyle{node convol}=[node,orange!20!black,draw=myorange!30!black,fill=myorange!20]\n\\tikzstyle{node out}=[node,red!20!black,draw=myred!30!black,fill=myred!20]\n\\tikzstyle{connect}=[thick,mydarkblue] %,line cap=round\n\\tikzstyle{connect arrow}=[-{Latex[length=4,width=3.5]},thick,mydarkblue,shorten &lt;=0.5,shorten &gt;=1]\n\\tikzset{ % node styles, numbered for easy mapping with \\nstyle\n  node 1/.style={node in},\n  node 2/.style={node hidden},\n  node 3/.style={node out},\n}\n\\def\\nstyle{int(\\lay&lt;\\Nnodlen?min(2,\\lay):3)} % map layer number onto 1, 2, or 3\n\n\n\\begin{tikzpicture}[x=2.7cm,y=1.6cm]\n  \\message{^^JNeural network activation}\n  \\def\\NI{5} % number of nodes in input layers\n  \\def\\NO{4} % number of nodes in output layers\n  \\def\\yshift{0.4} % shift last node for dots\n  \n  % INPUT LAYER\n  \\foreach \\i [evaluate={\\c=int(\\i==\\NI); \\y=\\NI/2-\\i-\\c*\\yshift; \\index=(\\i&lt;\\NI?int(\\i):\"n\");}]\n              in {1,...,\\NI}{ % loop over nodes\n    \\node[node in,outer sep=0.6] (NI-\\i) at (0,\\y) {$a_{\\index}^{(0)}$};\n  }\n  \n  % OUTPUT LAYER\n  \\foreach \\i [evaluate={\\c=int(\\i==\\NO); \\y=\\NO/2-\\i-\\c*\\yshift; \\index=(\\i&lt;\\NO?int(\\i):\"m\");}]\n    in {\\NO,...,1}{ % loop over nodes\n    \\ifnum\\i=1 % high-lighted node\n      \\node[node hidden]\n        (NO-\\i) at (1,\\y) {$a_{\\index}^{(1)}$};\n      \\foreach \\j [evaluate={\\index=(\\j&lt;\\NI?int(\\j):\"n\");}] in {1,...,\\NI}{ % loop over nodes in previous layer\n        \\draw[connect,white,line width=1.2] (NI-\\j) -- (NO-\\i);\n        \\draw[connect] (NI-\\j) -- (NO-\\i)\n          node[pos=0.50] {\\contour{white}{$w_{1,\\index}$}};\n      }\n    \\else % other light-colored nodes\n      \\node[node,blue!20!black!80,draw=myblue!20,fill=myblue!5]\n        (NO-\\i) at (1,\\y) {$a_{\\index}^{(1)}$};\n      \\foreach \\j in {1,...,\\NI}{ % loop over nodes in previous layer\n        %\\draw[connect,white,line width=1.2] (NI-\\j) -- (NO-\\i);\n        \\draw[connect,myblue!20] (NI-\\j) -- (NO-\\i);\n      }\n    \\fi\n  }\n  \n  % DOTS\n  \\path (NI-\\NI) --++ (0,1+\\yshift) node[midway,scale=1.2] {$\\vdots$};\n  \\path (NO-\\NO) --++ (0,1+\\yshift) node[midway,scale=1.2] {$\\vdots$};\n  \n  % EQUATIONS\n  \\def\\agr#1{{\\color{mydarkgreen}a_{#1}^{(0)}}}\n  \\node[below=17,right=11,mydarkblue,scale=0.95] at (NO-1)\n    {$\\begin{aligned} %\\underset{\\text{bias}}{b_1}\n       &= \\color{mydarkred}\\sigma\\left( \\color{black}\n            w_{1,0}\\agr{0} + w_{1,1}\\agr{1} + \\ldots + w_{1,n}\\agr{n} + b_1^{(0)}\n          \\color{mydarkred}\\right)\\\\\n       &= \\color{mydarkred}\\sigma\\left( \\color{black}\n            \\sum_{i=1}^{n} w_{1,i}\\agr{i} + b_1^{(0)}\n           \\color{mydarkred}\\right)\n     \\end{aligned}$};\n  \\node[right,scale=0.9] at (1.3,-1.3)\n    {$\\begin{aligned}\n      {\\color{mydarkblue}\n      \\begin{pmatrix}\n        a_{1}^{(1)} \\\\[0.3em]\n        a_{2}^{(1)} \\\\\n        \\vdots \\\\\n        a_{m}^{(1)}\n      \\end{pmatrix}}\n      &=\n      \\color{mydarkred}\\sigma\\left[ \\color{black}\n      \\begin{pmatrix}\n        w_{1,0} & w_{1,1} & \\ldots & w_{1,n} \\\\\n        w_{2,0} & w_{2,1} & \\ldots & w_{2,n} \\\\\n        \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n        w_{m,0} & w_{m,1} & \\ldots & w_{m,n}\n      \\end{pmatrix}\n      {\\color{mydarkgreen}\n      \\begin{pmatrix}\n        a_{1}^{(0)} \\\\[0.3em]\n        a_{2}^{(0)} \\\\\n        \\vdots \\\\\n        a_{n}^{(0)}\n      \\end{pmatrix}}\n      +\n      \\begin{pmatrix}\n        b_{1}^{(0)} \\\\[0.3em]\n        b_{2}^{(0)} \\\\\n        \\vdots \\\\\n        b_{m}^{(0)}\n      \\end{pmatrix}\n      \\color{mydarkred}\\right]\\\\[0.5em]\n      {\\color{mydarkblue}a^{(1)}}\n      &= \\color{mydarkred}\\sigma\\left( \\color{black}\n           \\mathbf{W}^{(0)} {\\color{mydarkgreen}a^{(0)}}+\\mathbf{b}^{(0)}\n         \\color{mydarkred}\\right)\n         %\\color{black},\\quad \\mathbf{W}^{(0)} \\in \\mathbb{R}^{m\\times n}\n    \\end{aligned}$};\n  \n\\end{tikzpicture}\n\n```\n\n\n\n\n\n\n\nAutoencoder\nhttps://tikz.net/autoencoder/\n\n\nCode\n```{r, engine = 'tikz', engine.opts=font_opts}\n#| eval: true\n#| cache: true\n\n\\newcommand{\\xin}[2]{$x_#2$}\n\\newcommand{\\xout}[2]{$\\hat x_#2$}\n\n\\begin{neuralnetwork}[height=8]\n  \\tikzstyle{input neuron}=[neuron, fill=orange!70];\n  \\tikzstyle{output neuron}=[neuron, fill=blue!60!black, text=white];\n\n  \\inputlayer[count=8, bias=false, title=Input Layer, text=\\xin]\n\n  \\hiddenlayer[count=5, bias=false]\n  \\linklayers\n\n  \\hiddenlayer[count=3, bias=false, title=Latent\\\\Representation]\n  \\linklayers\n\n  \\hiddenlayer[count=5, bias=false]\n  \\linklayers\n\n  \\outputlayer[count=8, title=Output Layer, text=\\xout]\n  \\linklayers\n\n\\end{neuralnetwork}\n\n```\n\n\n\n\n\n\n\nVAE\nhttps://tikz.net/vae/\n\n\nCode\n```{r, engine = 'tikz', engine.opts=font_opts, cache=TRUE}\n#| eval: true\n\n\\usetikzlibrary{fit,positioning}\n\n\\newcommand\\drawNodes[2]{\n  % #1 (str): namespace\n  % #2 (list[list[str]]): list of labels to print in the node of each neuron\n  \\foreach \\neurons [count=\\lyrIdx] in #2 {\n    \\StrCount{\\neurons}{,}[\\lyrLength] % use xstring package to save each layer size into \\lyrLength macro\n    \\foreach \\n [count=\\nIdx] in \\neurons\n      \\node[neuron] (#1-\\lyrIdx-\\nIdx) at (2*\\lyrIdx, \\lyrLength/2-1.4*\\nIdx) {\\n};\n  }\n}\n\n\\newcommand\\denselyConnectNodes[2]{\n  % #1 (str): namespace\n  % #2 (list[int]): number of nodes in each layer\n  \\foreach \\n [count=\\lyrIdx, remember=\\lyrIdx as \\previdx, remember=\\n as \\prevn] in #2 {\n    \\foreach \\y in {1,...,\\n} {\n      \\ifnum \\lyrIdx &gt; 1\n        \\foreach \\x in {1,...,\\prevn}\n          \\draw[-&gt;] (#1-\\previdx-\\x) -- (#1-\\lyrIdx-\\y);\n      \\fi\n    }\n  }\n}\n\n\\begin{tikzpicture}[\n    shorten &gt;=1pt, shorten &lt;=1pt,\n    neuron/.style={circle, draw, minimum size=4ex, thick},\n    legend/.style={font=\\large\\bfseries},\n  ]\n\n  % encoder\n  \\drawNodes{encoder}{{{,,,,}, {,,,}, {,,}}}\n  \\denselyConnectNodes{encoder}{{5, 4, 3}}\n\n  % decoder\n  \\begin{scope}[xshift=11cm]\n    \\drawNodes{decoder}{{{,,}, {,,,}, {,,,,}}}\n    \\denselyConnectNodes{decoder}{{3, 4, 5}}\n  \\end{scope}\n\n  % mu, sigma, sample nodes\n  \\foreach \\idx in {1,...,3} {\n      \\coordinate[neuron, right=2 of encoder-3-2, yshift=\\idx cm,, fill=yellow, fill opacity=0.2] (mu-\\idx);\n      \\coordinate[neuron, right=2 of encoder-3-2, yshift=-\\idx cm, fill=blue, fill opacity=0.1] (sigma-\\idx);\n      \\coordinate[neuron, right=4 of encoder-3-2, yshift=\\idx cm-2cm, fill=green, fill opacity=0.1] (sample-\\idx);\n    }\n\n  % mu, sigma, sample boxes\n  \\node [label=$\\mu$, fit=(mu-1) (mu-3), draw, fill=yellow, opacity=0.45] (mu) {};\n  \\node [label=$\\sigma$, fit=(sigma-1) (sigma-3), draw, fill=blue, opacity=0.3] (sigma) {};\n  \\node [label=sample, fit=(sample-1) (sample-3), draw, fill=green, opacity=0.3] (sample) {};\n\n  % mu, sigma, sample connections\n  \\draw[-&gt;] (mu.east) edge (sample.west) (sigma.east) -- (sample.west);\n  \\foreach \\a in {1,2,3}\n  \\foreach \\b in {1,2,3} {\n      \\draw[-&gt;] (encoder-3-\\a) -- (mu-\\b);\n      \\draw[-&gt;] (encoder-3-\\a) -- (sigma-\\b);\n      \\draw[-&gt;] (sample-\\a) -- (decoder-1-\\b);\n    }\n\n  % input + output labels\n  \\foreach \\idx in {1,...,5} {\n      \\node[left=0 of encoder-1-\\idx] {$x_\\idx$};\n      \\node[right=0 of decoder-3-\\idx] {$\\hat x_\\idx$};\n    }\n  \\node[above=0.1 of encoder-1-1] {input};\n  \\node[above=0.1 of decoder-3-1] {output};\n\n\\end{tikzpicture}\n\n```"
  },
  {
    "objectID": "Visuals_Interactives/tikz_net.html#intro-1",
    "href": "Visuals_Interactives/tikz_net.html#intro-1",
    "title": "tikz",
    "section": "Intro",
    "text": "Intro\nHere is a TikZ picture\n{r, engine = 'tikz'} #| eval: false \\begin{tikzpicture}  \\draw (0,0) circle (1cm);  % \\draw (0,0) circle (2cm); \\end{tikzpicture}\n```{r, engine = ‘tikz’}\n\n\n\n\n```{tikz complete-pooling, engine.opts=font_opts}\n#| echo: false\n#| fig-cap: \"Complete pooling\"\n#| fig-align: center\n#| fig-ext: svg\n#| out-width: 100%\n\\usetikzlibrary{positioning}\n\\usetikzlibrary{shapes.geometric}\n\\begin{tikzpicture}[{every node/.append style}=draw]\n  \\node [rectangle] (pop) at (0, 4) {Population};\n  \\node [ellipse] (y1) at (-5, 2.5) {$y_1$};\n  \\node [ellipse] (y2) at (-3, 2.5) {$y_2$};\n  \\node [ellipse] (y3) at (-1, 2.5) {$y_3$};\n  \\node [ellipse] (y4) at (1, 2.5) {$y_4$};\n  \\node [ellipse, draw=white] (ydots) at (3, 2.5) {$\\dots$};\n  \\node [ellipse] (yn) at (5, 2.5) {$y_n$};\n  \\draw [-latex] (pop) to (y1);\n  \\draw [-latex] (pop) to (y2);\n  \\draw [-latex] (pop) to (y3);\n  \\draw [-latex] (pop) to (y4);\n  \\draw [-latex, dashed] (pop) to (ydots);\n  \\draw [-latex] (pop) to (yn);\n\\end{tikzpicture}"
  },
  {
    "objectID": "Visuals_Interactives/tikz_net.html#alm",
    "href": "Visuals_Interactives/tikz_net.html#alm",
    "title": "tikz",
    "section": "ALM",
    "text": "ALM\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: false\n\\usetikzlibrary{positioning}\n\n\\def\\layersep{3.5cm}\n\n\\begin{tikzpicture}[shorten &gt;=1pt,-&gt;,draw=black!50, node distance=\\layersep]\n    \\tikzstyle{every pin edge}=[&lt;-,shorten &lt;=1pt]\n    \\tikzstyle{neuron}=[circle,fill=black!25,minimum size=17pt,inner sep=0pt]\n    \\tikzstyle{input neuron}=[neuron, fill=green!50];\n    \\tikzstyle{output neuron}=[neuron, fill=red!50];\n    \\tikzstyle{annot} = [text width=4em, text centered]\n\n    % Draw the input layer nodes\n    \\foreach \\name / \\y in {1,2}\n        \\node[input neuron, pin=left:Input \\#\\y] (I-\\name) at (0,-\\y) {};\n\n    % Draw the output layer nodes\n    \\foreach \\name / \\y in {1,2,3}\n        \\path[yshift=1.0cm]\n            node[output neuron] (O-\\name) at (\\layersep,-\\y cm) {};\n\n    % Connect every node in the input layer with every node in the\n    % output layer.\n    \\foreach \\source in {1,2}\n        \\foreach \\dest in {1,2,3}\n            \\path (I-\\source) edge (O-\\dest);\n\n    % Annotate the layers with equations\n    \\node[above of=I-1, node distance=1.5cm] (il) {$a_i(X)=e^{-\\gamma \\cdot (X-X_i)^2}$ \\\\ $\\frac{a_i(X)}{\\sum a_i(X)}$};\n    \\node[above of=O-1, node distance=1.5cm] (ol) {$O_j(X)=\\sum_{i=1}^M w_{j i} \\cdot a_i(X)$ \\\\ $P[Y_j|X]=\\frac{O_j(X)}{\\sum_{k=1}^L O_k(X)}$};\n\\end{tikzpicture}\n\n```\n\n\n\n\nCode\n```{r, engine = 'tikz'}\n#| eval: false\n#|\n\\usetikzlibrary{positioning}\n\n\\def\\layersep{3.5cm}\n\n\\begin{tikzpicture}[shorten &gt;=1pt,-&gt;,draw=black!50, node distance=\\layersep]\n    \\tikzstyle{every pin edge}=[&lt;-,shorten &lt;=1pt]\n    \\tikzstyle{neuron}=[circle,fill=black!25,minimum size=17pt,inner sep=0pt]\n    \\tikzstyle{input neuron}=[neuron, fill=green!50];\n    \\tikzstyle{output neuron}=[neuron, fill=red!50];\n    \\tikzstyle{annot} = [text width=4em, text centered]\n\n    % Draw the input layer nodes\n    \\foreach \\name / \\y in {1,2}\n        \\node[input neuron, pin=left:Input \\#\\y] (I-\\name) at (0,-\\y) {$X_{\\y}$};\n\n    % Draw the output layer nodes\n    \\foreach \\name / \\y in {1,2,3}\n        \\path[yshift=1.0cm]\n            node[output neuron] (O-\\name) at (\\layersep,-\\y cm) {$Y_{\\y}$};\n\n    % Connect every node in the input layer with every node in the\n    % output layer.\n    \\foreach \\source in {1,2}\n        \\foreach \\dest in {1,2,3}\n            \\path (I-\\source) edge (O-\\dest);\n\n    % Annotate the layers with equations\n    \\node[above of=I-1, node distance=1.5cm] (il) {$a_i(X)=e^{-\\gamma \\cdot (X-X_i)^2}$ \\\\ $\\frac{a_i(X)}{\\sum