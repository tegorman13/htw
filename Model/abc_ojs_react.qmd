---
title: "abc_ojs_react"
format:
  html:
    echo: false
    code-tools: true
eval: false
---



```{r}
pacman::p_load(dplyr,purrr,tidyr,ggplot2, data.table, here, patchwork, conflicted, 
               stringr,future,furrr, knitr, reactable, flextable,ggstance, htmltools)
conflict_prefer_all("dplyr", quiet = TRUE)
options(scipen = 999)
walk(c("Display_Functions","fun_alm","fun_indv_fit","fun_model"), ~ source(here::here(paste0("Functions/", .x, ".R"))))
ds <- readRDS(here::here("data/e1_md_11-06-23.rds"))  |> as.data.table()
input_layer <<- output_layer <<-  c(100,350,600,800,1000,1200)

ids <- c(1,2,4,5,6,7,8, 10,11,12,13)
ids2 <- c(1,66,36)
ids3 <- c(20,71,101,4,76,192)
idsBad <- c(76,192, 101)


#file_name <- "n_iter_300_ntry_3000_0800"
#file_name <- "n_iter_100_ntry_200_4509"
file_name <- "n_iter_100_ntry_400_3247"
file_name <- "n_iter_200_ntry_300_5354"

# list.files(here('data/abc_reject'))
# (grep("Train",list.files(here(paste0('data/abc_reject/',file_name)),
#                                            pattern="EXAM_Test",full.names = TRUE),
#                                 invert=TRUE, value=TRUE))


ind_fits <- map(list.files(here(paste0('data/abc_reject/'),file_name),full.names=TRUE), readRDS)
# ind_fits <- map(list.files(here('data/abc_reject/n_iter_2000_ntry_10_2918'),full.names=TRUE), readRDS)
ind_fits_df <- ind_fits |> map(~list(dat=.x[[1]], Model = .x[["Model"]], Fit_Method=.x[["Fit_Method"]]))
ind_fits_df <- ind_fits_df |> map(~rbindlist(.x$dat) |> mutate(Model = .x$Model, Fit_Method = .x$Fit_Method)) |> rbindlist() 


#run_params <- tibble::lst(file_name,cMean=ind_fits[[1]]$cMean, cSig=ind_fits[[1]]$cSig, 
                          
run_params <- keep(ind_fits[[1]], ~any(class(.x) %in% c("character", "numeric")))
run_params <- tibble(!!!run_params) |> select(-Model,-Fit_Method)

extract_info <- function(raw_names, run_params) {
  fname <- tools::file_path_sans_ext(basename(raw_names))
  n_samp <- str_extract(raw_names, "(?<=_)\\d+(?=_)")
  ntry_ <- str_extract(raw_names, "(?<=ntry_)\\d+")
  type <- 'ss'
  data.frame(run_params, n_samp, ntry_, type, fname)
}

run_info <- extract_info(file_name,run_params)

```



```{r}

generate_data <- function(Model, post_samples, data, num_samples = 1, return_dat = "train_data, test_data") {
  # Filter data for the specific id without invalidating selfref
  sbj_data <- copy(data[id == post_samples$id[1]])
  simulation_function <- ifelse(Model == "EXAM", full_sim_exam, full_sim_alm)

  target_data <- switch(return_dat,
                        "test_data" = copy(sbj_data[expMode2 == "Test"]),
                        "train_data" = copy(sbj_data[expMode2 == "Train"]),
                        "train_data, test_data" = copy(sbj_data[expMode2 %in% c("Test", "Train")]))
  
  post_samples <- post_samples[order(mean_error)][1:num_samples, .(c, lr, mean_error, rank = .I)]

  simulated_data_list <- lapply(1:nrow(post_samples), function(i) {
    params <- post_samples[i]
    sim_data <- simulation_function(sbj_data, params$c, params$lr, input_layer = input_layer, 
                                    output_layer = output_layer, return_dat = return_dat)
    sim_data_dt <- data.table(id = sbj_data$id[1], condit = sbj_data$condit[1], 
                              expMode2 = target_data$expMode2, Model = Model,tr=target_data$tr,
                              y = target_data$y, x = target_data$x, c = params$c, 
                              lr = params$lr, mean_error = params$mean_error, rank = i,
                              pred = sim_data)
    return(sim_data_dt)
  })
  
  result_dt <- rbindlist(simulated_data_list)
  setcolorder(result_dt, c("id", "condit", "expMode2","tr", "c", "lr", "x", "y", "pred"))
  return(result_dt)
}

future::plan(multisession)

nestSbjModelFit <- ind_fits_df %>% nest(.by=c(id,Model,Fit_Method))

# organize test data predictions
post_dat <- nestSbjModelFit |> mutate(pp=furrr::future_pmap(list(id,Model,Fit_Method,data), ~{
   generate_data(..2, ..4 |> mutate(id=..1), ds, num_samples = 50, return_dat="test_data")
   })) |> 
  select(Fit_Method,pp,-data) |>  
  unnest(pp) |>  filter(expMode2=="Test") |> as.data.table()

post_dat_avg <- post_dat |> group_by(id, condit, Model, Fit_Method, x, c, lr, rank) |> 
  summarise(y = mean(y), pred = mean(pred), error = y - pred) |> as.data.table()

setorder(post_dat_avg, id, x, rank)

```


```{r}

data <- post_dat |> group_by(condit,Model,Fit_Method,rank,x) |>
   mutate(e2=abs(y-pred)) |> 
  summarise(y=mean(y), pred=mean(pred), mean_error=mean(e2)) |> 
    round_tibble(1) 
  
reactable(data,wrap=FALSE,filterable = TRUE, resizable = TRUE, elementId="tbl")

```

```{ojs}
//| panel: input
viewof rank = Inputs.range(
  [1, 50], 
  { value: 50, step: 1, label: "Rank:" }
)

viewof Fit_Method = Inputs.checkbox(
  ["Test", "Test_Train", "Train"], 
  { value: ["Test", "Test_Train"], label: "Fit_Method:" }
)
```

```{ojs}
// Update table filters when filtered data changes
Reactable.setFilter('tbl', 'rank', rank)
Reactable.setFilter('tbl', 'Fit_Method', Fit_Method)

```





```{ojs}
// Create an Observable value that automatically tracks the table's filtered data
filteredData = Generators.observe(change => {
  return Reactable.onStateChange('tbl', state => {
    change(state.sortedData)
  })
})
```


